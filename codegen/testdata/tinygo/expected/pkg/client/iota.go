// Code generated by @apexlang/codegen. DO NOT EDIT.

package client

import (
	"context"
	"encoding/binary"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/nanobus/iota/go/invoke"
	"github.com/nanobus/iota/go/msgpack"
	"github.com/nanobus/iota/go/msgpack/convert"
	"github.com/nanobus/iota/go/payload"
	"github.com/nanobus/iota/go/proxy"
	"github.com/nanobus/iota/go/rx/flux"
	"github.com/nanobus/iota/go/rx/mono"
	"github.com/nanobus/iota/go/transform"
)

type MyAlias string

type SomeCalcFn func(ctx context.Context, rhs int64, lhs int64) mono.Mono[int64]

type MyStreamer interface {
	RequestStreamI64(ctx context.Context) flux.Flux[int64]
	RequestStreamF64(ctx context.Context) flux.Flux[float64]
	RequestStreamType(ctx context.Context) flux.Flux[MyType]
	RequestStreamEnum(ctx context.Context) flux.Flux[MyEnum]
	RequestStreamUUID(ctx context.Context) flux.Flux[uuid.UUID]
	RequestStreamAlias(ctx context.Context) flux.Flux[MyAlias]
	RequestStreamString(ctx context.Context) flux.Flux[string]
	RequestStreamBool(ctx context.Context) flux.Flux[bool]
	RequestStreamDatetime(ctx context.Context) flux.Flux[time.Time]
	RequestStreamList(ctx context.Context) flux.Flux[[]string]
	RequestStreamMap(ctx context.Context) flux.Flux[map[string]string]
	RequestStreamArgsI64(ctx context.Context, value int64) flux.Flux[int64]
	RequestStreamArgsF64(ctx context.Context, value float64) flux.Flux[float64]
	RequestStreamArgsType(ctx context.Context, value *MyType) flux.Flux[MyType]
	RequestStreamArgsEnum(ctx context.Context, value MyEnum) flux.Flux[MyEnum]
	RequestStreamArgsUUID(ctx context.Context, value uuid.UUID) flux.Flux[uuid.UUID]
	RequestStreamArgsAlias(ctx context.Context, value MyAlias) flux.Flux[MyAlias]
	RequestStreamArgsString(ctx context.Context, value string) flux.Flux[string]
	RequestStreamArgsBool(ctx context.Context, value bool) flux.Flux[bool]
	RequestStreamArgsDatetime(ctx context.Context, value time.Time) flux.Flux[time.Time]
	RequestStreamArgsList(ctx context.Context, value []string) flux.Flux[[]string]
	RequestStreamArgsMap(ctx context.Context, value map[string]string) flux.Flux[map[string]string]
	RequestChannelVoid(ctx context.Context, in flux.Flux[int64]) mono.Void
	RequestChannelSingle(ctx context.Context, in flux.Flux[int64]) mono.Mono[int64]
	RequestChannelI64(ctx context.Context, in flux.Flux[int64]) flux.Flux[int64]
	RequestChannelF64(ctx context.Context, in flux.Flux[float64]) flux.Flux[float64]
	RequestChannelType(ctx context.Context, in flux.Flux[MyType]) flux.Flux[MyType]
	RequestChannelEnum(ctx context.Context, in flux.Flux[MyEnum]) flux.Flux[MyEnum]
	RequestChannelAlias(ctx context.Context, in flux.Flux[uuid.UUID]) flux.Flux[uuid.UUID]
	RequestChannelString(ctx context.Context, in flux.Flux[string]) flux.Flux[string]
	RequestChannelBool(ctx context.Context, in flux.Flux[bool]) flux.Flux[bool]
	RequestChannelDatetime(ctx context.Context, in flux.Flux[time.Time]) flux.Flux[time.Time]
	RequestChannelList(ctx context.Context, in flux.Flux[[]string]) flux.Flux[[]string]
	RequestChannelMap(ctx context.Context, in flux.Flux[map[string]string]) flux.Flux[map[string]string]
	RequestChannelArgsSingle(ctx context.Context, value int64, in flux.Flux[int64]) mono.Mono[int64]
	RequestChannelArgsI64(ctx context.Context, value int64, in flux.Flux[int64]) flux.Flux[int64]
	RequestChannelArgsF64(ctx context.Context, value float64, in flux.Flux[float64]) flux.Flux[float64]
	RequestChannelArgsType(ctx context.Context, value *MyType, in flux.Flux[MyType]) flux.Flux[MyType]
	RequestChannelArgsEnum(ctx context.Context, value MyEnum, in flux.Flux[MyEnum]) flux.Flux[MyEnum]
	RequestChannelArgsAlias(ctx context.Context, value uuid.UUID, in flux.Flux[uuid.UUID]) flux.Flux[uuid.UUID]
	RequestChannelArgsString(ctx context.Context, value string, in flux.Flux[string]) flux.Flux[string]
	RequestChannelArgsBool(ctx context.Context, value bool, in flux.Flux[bool]) flux.Flux[bool]
	RequestChannelArgsDatetime(ctx context.Context, value time.Time, in flux.Flux[time.Time]) flux.Flux[time.Time]
	RequestChannelArgsList(ctx context.Context, value []string, in flux.Flux[[]string]) flux.Flux[[]string]
	RequestChannelArgsMap(ctx context.Context, value map[string]string, in flux.Flux[map[string]string]) flux.Flux[map[string]string]
}

type MyService interface {
	EmptyVoid(ctx context.Context) mono.Void
	UnaryType(ctx context.Context, value *MyType) mono.Mono[MyType]
	UnaryEnum(ctx context.Context, value MyEnum) mono.Mono[MyEnum]
	UnaryUUID(ctx context.Context, value uuid.UUID) mono.Mono[uuid.UUID]
	UnaryAlias(ctx context.Context, value MyAlias) mono.Mono[MyAlias]
	UnaryString(ctx context.Context, value string) mono.Mono[string]
	UnaryI64(ctx context.Context, value int64) mono.Mono[int64]
	UnaryI32(ctx context.Context, value int32) mono.Mono[int32]
	UnaryI16(ctx context.Context, value int16) mono.Mono[int16]
	UnaryI8(ctx context.Context, value int8) mono.Mono[int8]
	UnaryU64(ctx context.Context, value uint64) mono.Mono[uint64]
	UnaryU32(ctx context.Context, value uint32) mono.Mono[uint32]
	UnaryU16(ctx context.Context, value uint16) mono.Mono[uint16]
	UnaryU8(ctx context.Context, value uint8) mono.Mono[uint8]
	UnaryF64(ctx context.Context, value float64) mono.Mono[float64]
	UnaryF32(ctx context.Context, value float32) mono.Mono[float32]
	UnaryBytes(ctx context.Context, value []byte) mono.Mono[[]byte]
	UnaryDatetime(ctx context.Context, value time.Time) mono.Mono[time.Time]
	UnaryList(ctx context.Context, value []string) mono.Mono[[]string]
	UnaryMap(ctx context.Context, value map[string]string) mono.Mono[map[string]string]
	FuncType(ctx context.Context, value *MyType, optional *MyType) mono.Mono[MyType]
	FuncEnum(ctx context.Context, value MyEnum, optional *MyEnum) mono.Mono[MyEnum]
	FuncUUID(ctx context.Context, value uuid.UUID, optional *uuid.UUID) mono.Mono[uuid.UUID]
	FuncAlias(ctx context.Context, value MyAlias, optional *MyAlias) mono.Mono[MyAlias]
	FuncString(ctx context.Context, value string, optional *string) mono.Mono[string]
	FuncI64(ctx context.Context, value int64, optional *int64) mono.Mono[int64]
	FuncI32(ctx context.Context, value int32, optional *int32) mono.Mono[int32]
	FuncI16(ctx context.Context, value int16, optional *int16) mono.Mono[int16]
	FuncI8(ctx context.Context, value int8, optional *int8) mono.Mono[int8]
	FuncU64(ctx context.Context, value uint64, optional *uint64) mono.Mono[uint64]
	FuncU32(ctx context.Context, value uint32, optional *uint32) mono.Mono[uint32]
	FuncU16(ctx context.Context, value uint16, optional *uint16) mono.Mono[uint16]
	FuncU8(ctx context.Context, value uint8, optional *uint8) mono.Mono[uint8]
	FuncF64(ctx context.Context, value float64, optional *float64) mono.Mono[float64]
	FuncF32(ctx context.Context, value float32, optional *float32) mono.Mono[float32]
	FuncBytes(ctx context.Context, value []byte, optional []byte) mono.Mono[[]byte]
	FuncDatetime(ctx context.Context, value time.Time, optional *time.Time) mono.Mono[time.Time]
	FuncList(ctx context.Context, value []string, optional []string) mono.Mono[[]string]
	FuncMap(ctx context.Context, value map[string]string, optional map[string]string) mono.Mono[map[string]string]
}

type Repository interface {
	GetData(ctx context.Context) mono.Mono[MyType]
}

// MyType is a class
type MyType struct {
	// same type value
	SameValue *MyType `json:"sameValue,omitempty" yaml:"sameValue,omitempty" msgpack:"sameValue,omitempty"`
	// type value
	TypeValue MyOtherType `json:"typeValue" yaml:"typeValue" msgpack:"typeValue"`
	// string value
	StringValue string `json:"stringValue" yaml:"stringValue" msgpack:"stringValue"`
	// string option
	StringOption *string `json:"stringOption,omitempty" yaml:"stringOption,omitempty" msgpack:"stringOption,omitempty"`
	// i64 value
	I64Value int64 `json:"i64Value" yaml:"i64Value" msgpack:"i64Value"`
	// i64 option
	I64Option *int64 `json:"i64Option,omitempty" yaml:"i64Option,omitempty" msgpack:"i64Option,omitempty"`
	// i32 value
	I32Value int32 `json:"i32Value" yaml:"i32Value" msgpack:"i32Value"`
	// i32 option
	I32Option *int32 `json:"i32Option,omitempty" yaml:"i32Option,omitempty" msgpack:"i32Option,omitempty"`
	// i16 value
	I16Value int16 `json:"i16Value" yaml:"i16Value" msgpack:"i16Value"`
	// i16 option
	I16Option *int16 `json:"i16Option,omitempty" yaml:"i16Option,omitempty" msgpack:"i16Option,omitempty"`
	// i8 value
	I8Value int8 `json:"i8Value" yaml:"i8Value" msgpack:"i8Value"`
	// i8 option
	I8Option *int8 `json:"i8Option,omitempty" yaml:"i8Option,omitempty" msgpack:"i8Option,omitempty"`
	// u64 value
	U64Value uint64 `json:"u64Value" yaml:"u64Value" msgpack:"u64Value"`
	// u64 option
	U64Option *uint64 `json:"u64Option,omitempty" yaml:"u64Option,omitempty" msgpack:"u64Option,omitempty"`
	// u32 value
	U32Value uint32 `json:"u32Value" yaml:"u32Value" msgpack:"u32Value"`
	// u32 option
	U32Option *uint32 `json:"u32Option,omitempty" yaml:"u32Option,omitempty" msgpack:"u32Option,omitempty"`
	// u16 value
	U16Value uint16 `json:"u16Value" yaml:"u16Value" msgpack:"u16Value"`
	// u16 option
	U16Option *uint16 `json:"u16Option,omitempty" yaml:"u16Option,omitempty" msgpack:"u16Option,omitempty"`
	// u8 value
	U8Value uint8 `json:"u8Value" yaml:"u8Value" msgpack:"u8Value"`
	// u8 option
	U8Option *uint8 `json:"u8Option,omitempty" yaml:"u8Option,omitempty" msgpack:"u8Option,omitempty"`
	// f64 value
	F64Value float64 `json:"f64Value" yaml:"f64Value" msgpack:"f64Value"`
	// f64 option
	F64Option *float64 `json:"f64Option,omitempty" yaml:"f64Option,omitempty" msgpack:"f64Option,omitempty"`
	// f32 value
	F32Value float32 `json:"f32Value" yaml:"f32Value" msgpack:"f32Value"`
	// f32 option
	F32Option *float32 `json:"f32Option,omitempty" yaml:"f32Option,omitempty" msgpack:"f32Option,omitempty"`
	// datetime value
	DatetimeValue time.Time `json:"datetimeValue" yaml:"datetimeValue" msgpack:"datetimeValue"`
	// datetime option
	DatetimeOption *time.Time `json:"datetimeOption,omitempty" yaml:"datetimeOption,omitempty" msgpack:"datetimeOption,omitempty"`
	// bytes value
	BytesValue []byte `json:"bytesValue" yaml:"bytesValue" msgpack:"bytesValue"`
	// bytes option
	BytesOption []byte `json:"bytesOption,omitempty" yaml:"bytesOption,omitempty" msgpack:"bytesOption,omitempty"`
	// map value
	MapValue map[string]int64 `json:"mapValue" yaml:"mapValue" msgpack:"mapValue"`
	// map of types
	MapOfTypes map[string]MyType `json:"mapOfTypes" yaml:"mapOfTypes" msgpack:"mapOfTypes"`
	// array value
	ArrayValue []string `json:"arrayValue" yaml:"arrayValue" msgpack:"arrayValue"`
	// array of types
	ArrayOfTypes []MyType `json:"arrayOfTypes" yaml:"arrayOfTypes" msgpack:"arrayOfTypes"`
	// union value
	UnionValue MyUnion `json:"unionValue" yaml:"unionValue" msgpack:"unionValue"`
	// union option
	UnionOption *MyUnion `json:"unionOption,omitempty" yaml:"unionOption,omitempty" msgpack:"unionOption,omitempty"`
	// enum value
	EnumValue MyEnum `json:"enumValue" yaml:"enumValue" msgpack:"enumValue"`
	// enum option
	EnumOption *MyEnum `json:"enumOption,omitempty" yaml:"enumOption,omitempty" msgpack:"enumOption,omitempty"`
	// enum value
	AliasValue uuid.UUID `json:"aliasValue" yaml:"aliasValue" msgpack:"aliasValue"`
	// enum option
	AliasOption *uuid.UUID `json:"aliasOption,omitempty" yaml:"aliasOption,omitempty" msgpack:"aliasOption,omitempty"`
}

// DefaultMyType returns a `MyType` struct populated with its default values.
func DefaultMyType() MyType {
	return MyType{}
}

type MyOtherType struct {
	Foo string `json:"foo" yaml:"foo" msgpack:"foo"`
	Bar string `json:"bar" yaml:"bar" msgpack:"bar"`
}

// DefaultMyOtherType returns a `MyOtherType` struct populated with its default
// values.
func DefaultMyOtherType() MyOtherType {
	return MyOtherType{}
}

type MyUnion struct {
	MyType *MyType `json:"MyType,omitempty" yaml:"MyType,omitempty" msgpack:"MyType,omitempty"`
	MyEnum *MyEnum `json:"MyEnum,omitempty" yaml:"MyEnum,omitempty" msgpack:"MyEnum,omitempty"`
	String *string `json:"string,omitempty" yaml:"string,omitempty" msgpack:"string,omitempty"`
}

// MyEnum is an emuneration
type MyEnum int32

const (
	// ONE value
	MyEnumOne MyEnum = 0
	// TWO value
	MyEnumTwo MyEnum = 1
	// THREE value
	MyEnumThree MyEnum = 2
)

var toStringMyEnum = map[MyEnum]string{
	MyEnumOne:   "one",
	MyEnumTwo:   "TWO",
	MyEnumThree: "three",
}

var toIDMyEnum = map[string]MyEnum{
	"one":   MyEnumOne,
	"TWO":   MyEnumTwo,
	"three": MyEnumThree,
}

func (e MyEnum) String() string {
	str, ok := toStringMyEnum[e]
	if !ok {
		return "unknown"
	}
	return str
}

func (e *MyEnum) FromString(str string) error {
	var ok bool
	*e, ok = toIDMyEnum[str]
	if !ok {
		return errors.New("unknown value \"" + str + "\" for MyEnum")
	}
	return nil
}

type SomeCalcArgs struct {
	Rhs int64 `json:"rhs" yaml:"rhs" msgpack:"rhs"`
	Lhs int64 `json:"lhs" yaml:"lhs" msgpack:"lhs"`
}

// DefaultSomeCalcArgs returns a `SomeCalcArgs` struct populated with its default
// values.
func DefaultSomeCalcArgs() SomeCalcArgs {
	return SomeCalcArgs{}
}

func (o *SomeCalcArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "rhs":
			o.Rhs, err = decoder.ReadInt64()
		case "lhs":
			o.Lhs, err = decoder.ReadInt64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *SomeCalcArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("rhs")
	encoder.WriteInt64(o.Rhs)
	encoder.WriteString("lhs")
	encoder.WriteInt64(o.Lhs)

	return nil
}

type MyStreamerRequestStreamArgsI64Args struct {
	Value int64 `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsI64Args returns a
// `MyStreamerRequestStreamArgsI64Args` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsI64Args() MyStreamerRequestStreamArgsI64Args {
	return MyStreamerRequestStreamArgsI64Args{}
}

func (o *MyStreamerRequestStreamArgsI64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsI64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteInt64(o.Value)

	return nil
}

type MyStreamerRequestStreamArgsF64Args struct {
	Value float64 `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsF64Args returns a
// `MyStreamerRequestStreamArgsF64Args` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsF64Args() MyStreamerRequestStreamArgsF64Args {
	return MyStreamerRequestStreamArgsF64Args{}
}

func (o *MyStreamerRequestStreamArgsF64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadFloat64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsF64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteFloat64(o.Value)

	return nil
}

type MyStreamerRequestStreamArgsTypeArgs struct {
	Value MyType `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsTypeArgs returns a
// `MyStreamerRequestStreamArgsTypeArgs` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsTypeArgs() MyStreamerRequestStreamArgsTypeArgs {
	return MyStreamerRequestStreamArgsTypeArgs{}
}

func (o *MyStreamerRequestStreamArgsTypeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			err = o.Value.Decode(decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsTypeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	o.Value.Encode(encoder)

	return nil
}

type MyStreamerRequestStreamArgsEnumArgs struct {
	Value MyEnum `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsEnumArgs returns a
// `MyStreamerRequestStreamArgsEnumArgs` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsEnumArgs() MyStreamerRequestStreamArgsEnumArgs {
	return MyStreamerRequestStreamArgsEnumArgs{}
}

func (o *MyStreamerRequestStreamArgsEnumArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Numeric[MyEnum](decoder.ReadInt32())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsEnumArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteInt32(int32(o.Value))

	return nil
}

type MyStreamerRequestStreamArgsUUIDArgs struct {
	Value uuid.UUID `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsUUIDArgs returns a
// `MyStreamerRequestStreamArgsUUIDArgs` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsUUIDArgs() MyStreamerRequestStreamArgsUUIDArgs {
	return MyStreamerRequestStreamArgsUUIDArgs{}
}

func (o *MyStreamerRequestStreamArgsUUIDArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsUUIDArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteString(o.Value.String())

	return nil
}

type MyStreamerRequestStreamArgsAliasArgs struct {
	Value MyAlias `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsAliasArgs returns a
// `MyStreamerRequestStreamArgsAliasArgs` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsAliasArgs() MyStreamerRequestStreamArgsAliasArgs {
	return MyStreamerRequestStreamArgsAliasArgs{}
}

func (o *MyStreamerRequestStreamArgsAliasArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.String[MyAlias](decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsAliasArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteString(string(o.Value))

	return nil
}

type MyStreamerRequestStreamArgsStringArgs struct {
	Value string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsStringArgs returns a
// `MyStreamerRequestStreamArgsStringArgs` struct populated with its default
// values.
func DefaultMyStreamerRequestStreamArgsStringArgs() MyStreamerRequestStreamArgsStringArgs {
	return MyStreamerRequestStreamArgsStringArgs{}
}

func (o *MyStreamerRequestStreamArgsStringArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsStringArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteString(o.Value)

	return nil
}

type MyStreamerRequestStreamArgsBoolArgs struct {
	Value bool `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsBoolArgs returns a
// `MyStreamerRequestStreamArgsBoolArgs` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsBoolArgs() MyStreamerRequestStreamArgsBoolArgs {
	return MyStreamerRequestStreamArgsBoolArgs{}
}

func (o *MyStreamerRequestStreamArgsBoolArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadBool()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsBoolArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteBool(o.Value)

	return nil
}

type MyStreamerRequestStreamArgsDatetimeArgs struct {
	Value time.Time `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsDatetimeArgs returns a
// `MyStreamerRequestStreamArgsDatetimeArgs` struct populated with its default
// values.
func DefaultMyStreamerRequestStreamArgsDatetimeArgs() MyStreamerRequestStreamArgsDatetimeArgs {
	return MyStreamerRequestStreamArgsDatetimeArgs{}
}

func (o *MyStreamerRequestStreamArgsDatetimeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadTime()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsDatetimeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteTime(o.Value)

	return nil
}

type MyStreamerRequestStreamArgsListArgs struct {
	Value []string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsListArgs returns a
// `MyStreamerRequestStreamArgsListArgs` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsListArgs() MyStreamerRequestStreamArgsListArgs {
	return MyStreamerRequestStreamArgsListArgs{}
}

func (o *MyStreamerRequestStreamArgsListArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadSlice(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsListArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteArraySize(uint32(len(o.Value)))
	for _, v := range o.Value {
		encoder.WriteString(v)
	}

	return nil
}

type MyStreamerRequestStreamArgsMapArgs struct {
	Value map[string]string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsMapArgs returns a
// `MyStreamerRequestStreamArgsMapArgs` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsMapArgs() MyStreamerRequestStreamArgsMapArgs {
	return MyStreamerRequestStreamArgsMapArgs{}
}

func (o *MyStreamerRequestStreamArgsMapArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadMap(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsMapArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteMapSize(uint32(len(o.Value)))
	if o.Value != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.Value {
			encoder.WriteString(k)
			encoder.WriteString(v)
		}
	}

	return nil
}

type MyStreamerRequestChannelArgsSingleArgs struct {
	Value int64 `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsSingleArgs returns a
// `MyStreamerRequestChannelArgsSingleArgs` struct populated with its default
// values.
func DefaultMyStreamerRequestChannelArgsSingleArgs() MyStreamerRequestChannelArgsSingleArgs {
	return MyStreamerRequestChannelArgsSingleArgs{}
}

func (o *MyStreamerRequestChannelArgsSingleArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsSingleArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteInt64(o.Value)

	return nil
}

type MyStreamerRequestChannelArgsI64Args struct {
	Value int64 `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsI64Args returns a
// `MyStreamerRequestChannelArgsI64Args` struct populated with its default values.
func DefaultMyStreamerRequestChannelArgsI64Args() MyStreamerRequestChannelArgsI64Args {
	return MyStreamerRequestChannelArgsI64Args{}
}

func (o *MyStreamerRequestChannelArgsI64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsI64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteInt64(o.Value)

	return nil
}

type MyStreamerRequestChannelArgsF64Args struct {
	Value float64 `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsF64Args returns a
// `MyStreamerRequestChannelArgsF64Args` struct populated with its default values.
func DefaultMyStreamerRequestChannelArgsF64Args() MyStreamerRequestChannelArgsF64Args {
	return MyStreamerRequestChannelArgsF64Args{}
}

func (o *MyStreamerRequestChannelArgsF64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadFloat64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsF64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteFloat64(o.Value)

	return nil
}

type MyStreamerRequestChannelArgsTypeArgs struct {
	Value MyType `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsTypeArgs returns a
// `MyStreamerRequestChannelArgsTypeArgs` struct populated with its default values.
func DefaultMyStreamerRequestChannelArgsTypeArgs() MyStreamerRequestChannelArgsTypeArgs {
	return MyStreamerRequestChannelArgsTypeArgs{}
}

func (o *MyStreamerRequestChannelArgsTypeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			err = o.Value.Decode(decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsTypeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	o.Value.Encode(encoder)

	return nil
}

type MyStreamerRequestChannelArgsEnumArgs struct {
	Value MyEnum `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsEnumArgs returns a
// `MyStreamerRequestChannelArgsEnumArgs` struct populated with its default values.
func DefaultMyStreamerRequestChannelArgsEnumArgs() MyStreamerRequestChannelArgsEnumArgs {
	return MyStreamerRequestChannelArgsEnumArgs{}
}

func (o *MyStreamerRequestChannelArgsEnumArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Numeric[MyEnum](decoder.ReadInt32())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsEnumArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteInt32(int32(o.Value))

	return nil
}

type MyStreamerRequestChannelArgsAliasArgs struct {
	Value uuid.UUID `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsAliasArgs returns a
// `MyStreamerRequestChannelArgsAliasArgs` struct populated with its default
// values.
func DefaultMyStreamerRequestChannelArgsAliasArgs() MyStreamerRequestChannelArgsAliasArgs {
	return MyStreamerRequestChannelArgsAliasArgs{}
}

func (o *MyStreamerRequestChannelArgsAliasArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsAliasArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteString(o.Value.String())

	return nil
}

type MyStreamerRequestChannelArgsStringArgs struct {
	Value string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsStringArgs returns a
// `MyStreamerRequestChannelArgsStringArgs` struct populated with its default
// values.
func DefaultMyStreamerRequestChannelArgsStringArgs() MyStreamerRequestChannelArgsStringArgs {
	return MyStreamerRequestChannelArgsStringArgs{}
}

func (o *MyStreamerRequestChannelArgsStringArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsStringArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteString(o.Value)

	return nil
}

type MyStreamerRequestChannelArgsBoolArgs struct {
	Value bool `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsBoolArgs returns a
// `MyStreamerRequestChannelArgsBoolArgs` struct populated with its default values.
func DefaultMyStreamerRequestChannelArgsBoolArgs() MyStreamerRequestChannelArgsBoolArgs {
	return MyStreamerRequestChannelArgsBoolArgs{}
}

func (o *MyStreamerRequestChannelArgsBoolArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadBool()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsBoolArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteBool(o.Value)

	return nil
}

type MyStreamerRequestChannelArgsDatetimeArgs struct {
	Value time.Time `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsDatetimeArgs returns a
// `MyStreamerRequestChannelArgsDatetimeArgs` struct populated with its default
// values.
func DefaultMyStreamerRequestChannelArgsDatetimeArgs() MyStreamerRequestChannelArgsDatetimeArgs {
	return MyStreamerRequestChannelArgsDatetimeArgs{}
}

func (o *MyStreamerRequestChannelArgsDatetimeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadTime()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsDatetimeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteTime(o.Value)

	return nil
}

type MyStreamerRequestChannelArgsListArgs struct {
	Value []string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsListArgs returns a
// `MyStreamerRequestChannelArgsListArgs` struct populated with its default values.
func DefaultMyStreamerRequestChannelArgsListArgs() MyStreamerRequestChannelArgsListArgs {
	return MyStreamerRequestChannelArgsListArgs{}
}

func (o *MyStreamerRequestChannelArgsListArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadSlice(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsListArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteArraySize(uint32(len(o.Value)))
	for _, v := range o.Value {
		encoder.WriteString(v)
	}

	return nil
}

type MyStreamerRequestChannelArgsMapArgs struct {
	Value map[string]string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsMapArgs returns a
// `MyStreamerRequestChannelArgsMapArgs` struct populated with its default values.
func DefaultMyStreamerRequestChannelArgsMapArgs() MyStreamerRequestChannelArgsMapArgs {
	return MyStreamerRequestChannelArgsMapArgs{}
}

func (o *MyStreamerRequestChannelArgsMapArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadMap(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsMapArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteMapSize(uint32(len(o.Value)))
	if o.Value != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.Value {
			encoder.WriteString(k)
			encoder.WriteString(v)
		}
	}

	return nil
}

type MyServiceFuncTypeArgs struct {
	Value    MyType  `json:"value" yaml:"value" msgpack:"value"`
	Optional *MyType `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncTypeArgs returns a `MyServiceFuncTypeArgs` struct populated
// with its default values.
func DefaultMyServiceFuncTypeArgs() MyServiceFuncTypeArgs {
	return MyServiceFuncTypeArgs{}
}

func (o *MyServiceFuncTypeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			err = o.Value.Decode(decoder)
		case "optional":
			o.Optional, err = msgpack.DecodeNillable[MyType](decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncTypeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	o.Value.Encode(encoder)
	encoder.WriteString("optional")
	o.Optional.Encode(encoder)

	return nil
}

type MyServiceFuncEnumArgs struct {
	Value    MyEnum  `json:"value" yaml:"value" msgpack:"value"`
	Optional *MyEnum `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncEnumArgs returns a `MyServiceFuncEnumArgs` struct populated
// with its default values.
func DefaultMyServiceFuncEnumArgs() MyServiceFuncEnumArgs {
	return MyServiceFuncEnumArgs{}
}

func (o *MyServiceFuncEnumArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Numeric[MyEnum](decoder.ReadInt32())
		case "optional":
			o.Optional, err = convert.NillableNumeric[MyEnum](decoder.ReadNillableInt32())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncEnumArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteInt32(int32(o.Value))
	encoder.WriteString("optional")
	encoder.WriteNillableInt32((*int32)(o.Optional))

	return nil
}

type MyServiceFuncUUIDArgs struct {
	Value    uuid.UUID  `json:"value" yaml:"value" msgpack:"value"`
	Optional *uuid.UUID `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncUUIDArgs returns a `MyServiceFuncUUIDArgs` struct populated
// with its default values.
func DefaultMyServiceFuncUUIDArgs() MyServiceFuncUUIDArgs {
	return MyServiceFuncUUIDArgs{}
}

func (o *MyServiceFuncUUIDArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "optional":
			o.Optional, err = convert.NillableParse(uuid.Parse)(decoder.ReadNillableString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncUUIDArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteString(o.Value.String())
	encoder.WriteString("optional")
	if o.Optional == nil {
		encoder.WriteNil()
	} else {
		encoder.WriteString(o.Optional.String())
	}

	return nil
}

type MyServiceFuncAliasArgs struct {
	Value    MyAlias  `json:"value" yaml:"value" msgpack:"value"`
	Optional *MyAlias `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncAliasArgs returns a `MyServiceFuncAliasArgs` struct
// populated with its default values.
func DefaultMyServiceFuncAliasArgs() MyServiceFuncAliasArgs {
	return MyServiceFuncAliasArgs{}
}

func (o *MyServiceFuncAliasArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.String[MyAlias](decoder.ReadString())
		case "optional":
			o.Optional, err = convert.NillableString[MyAlias](decoder.ReadNillableString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncAliasArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteString(string(o.Value))
	encoder.WriteString("optional")
	encoder.WriteNillableString((*string)(o.Optional))

	return nil
}

type MyServiceFuncStringArgs struct {
	Value    string  `json:"value" yaml:"value" msgpack:"value"`
	Optional *string `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncStringArgs returns a `MyServiceFuncStringArgs` struct
// populated with its default values.
func DefaultMyServiceFuncStringArgs() MyServiceFuncStringArgs {
	return MyServiceFuncStringArgs{}
}

func (o *MyServiceFuncStringArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadString()
		case "optional":
			o.Optional, err = decoder.ReadNillableString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncStringArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteString(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableString(o.Optional)

	return nil
}

type MyServiceFuncI64Args struct {
	Value    int64  `json:"value" yaml:"value" msgpack:"value"`
	Optional *int64 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncI64Args returns a `MyServiceFuncI64Args` struct populated
// with its default values.
func DefaultMyServiceFuncI64Args() MyServiceFuncI64Args {
	return MyServiceFuncI64Args{}
}

func (o *MyServiceFuncI64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt64()
		case "optional":
			o.Optional, err = decoder.ReadNillableInt64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncI64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteInt64(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableInt64(o.Optional)

	return nil
}

type MyServiceFuncI32Args struct {
	Value    int32  `json:"value" yaml:"value" msgpack:"value"`
	Optional *int32 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncI32Args returns a `MyServiceFuncI32Args` struct populated
// with its default values.
func DefaultMyServiceFuncI32Args() MyServiceFuncI32Args {
	return MyServiceFuncI32Args{}
}

func (o *MyServiceFuncI32Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt32()
		case "optional":
			o.Optional, err = decoder.ReadNillableInt32()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncI32Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteInt32(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableInt32(o.Optional)

	return nil
}

type MyServiceFuncI16Args struct {
	Value    int16  `json:"value" yaml:"value" msgpack:"value"`
	Optional *int16 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncI16Args returns a `MyServiceFuncI16Args` struct populated
// with its default values.
func DefaultMyServiceFuncI16Args() MyServiceFuncI16Args {
	return MyServiceFuncI16Args{}
}

func (o *MyServiceFuncI16Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt16()
		case "optional":
			o.Optional, err = decoder.ReadNillableInt16()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncI16Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteInt16(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableInt16(o.Optional)

	return nil
}

type MyServiceFuncI8Args struct {
	Value    int8  `json:"value" yaml:"value" msgpack:"value"`
	Optional *int8 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncI8Args returns a `MyServiceFuncI8Args` struct populated with
// its default values.
func DefaultMyServiceFuncI8Args() MyServiceFuncI8Args {
	return MyServiceFuncI8Args{}
}

func (o *MyServiceFuncI8Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt8()
		case "optional":
			o.Optional, err = decoder.ReadNillableInt8()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncI8Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteInt8(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableInt8(o.Optional)

	return nil
}

type MyServiceFuncU64Args struct {
	Value    uint64  `json:"value" yaml:"value" msgpack:"value"`
	Optional *uint64 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncU64Args returns a `MyServiceFuncU64Args` struct populated
// with its default values.
func DefaultMyServiceFuncU64Args() MyServiceFuncU64Args {
	return MyServiceFuncU64Args{}
}

func (o *MyServiceFuncU64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadUint64()
		case "optional":
			o.Optional, err = decoder.ReadNillableUint64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncU64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteUint64(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableUint64(o.Optional)

	return nil
}

type MyServiceFuncU32Args struct {
	Value    uint32  `json:"value" yaml:"value" msgpack:"value"`
	Optional *uint32 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncU32Args returns a `MyServiceFuncU32Args` struct populated
// with its default values.
func DefaultMyServiceFuncU32Args() MyServiceFuncU32Args {
	return MyServiceFuncU32Args{}
}

func (o *MyServiceFuncU32Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadUint32()
		case "optional":
			o.Optional, err = decoder.ReadNillableUint32()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncU32Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteUint32(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableUint32(o.Optional)

	return nil
}

type MyServiceFuncU16Args struct {
	Value    uint16  `json:"value" yaml:"value" msgpack:"value"`
	Optional *uint16 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncU16Args returns a `MyServiceFuncU16Args` struct populated
// with its default values.
func DefaultMyServiceFuncU16Args() MyServiceFuncU16Args {
	return MyServiceFuncU16Args{}
}

func (o *MyServiceFuncU16Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadUint16()
		case "optional":
			o.Optional, err = decoder.ReadNillableUint16()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncU16Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteUint16(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableUint16(o.Optional)

	return nil
}

type MyServiceFuncU8Args struct {
	Value    uint8  `json:"value" yaml:"value" msgpack:"value"`
	Optional *uint8 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncU8Args returns a `MyServiceFuncU8Args` struct populated with
// its default values.
func DefaultMyServiceFuncU8Args() MyServiceFuncU8Args {
	return MyServiceFuncU8Args{}
}

func (o *MyServiceFuncU8Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadUint8()
		case "optional":
			o.Optional, err = decoder.ReadNillableUint8()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncU8Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteUint8(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableUint8(o.Optional)

	return nil
}

type MyServiceFuncF64Args struct {
	Value    float64  `json:"value" yaml:"value" msgpack:"value"`
	Optional *float64 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncF64Args returns a `MyServiceFuncF64Args` struct populated
// with its default values.
func DefaultMyServiceFuncF64Args() MyServiceFuncF64Args {
	return MyServiceFuncF64Args{}
}

func (o *MyServiceFuncF64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadFloat64()
		case "optional":
			o.Optional, err = decoder.ReadNillableFloat64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncF64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteFloat64(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableFloat64(o.Optional)

	return nil
}

type MyServiceFuncF32Args struct {
	Value    float32  `json:"value" yaml:"value" msgpack:"value"`
	Optional *float32 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncF32Args returns a `MyServiceFuncF32Args` struct populated
// with its default values.
func DefaultMyServiceFuncF32Args() MyServiceFuncF32Args {
	return MyServiceFuncF32Args{}
}

func (o *MyServiceFuncF32Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadFloat32()
		case "optional":
			o.Optional, err = decoder.ReadNillableFloat32()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncF32Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteFloat32(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableFloat32(o.Optional)

	return nil
}

type MyServiceFuncBytesArgs struct {
	Value    []byte `json:"value" yaml:"value" msgpack:"value"`
	Optional []byte `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncBytesArgs returns a `MyServiceFuncBytesArgs` struct
// populated with its default values.
func DefaultMyServiceFuncBytesArgs() MyServiceFuncBytesArgs {
	return MyServiceFuncBytesArgs{}
}

func (o *MyServiceFuncBytesArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadByteArray()
		case "optional":
			o.Optional, err = decoder.ReadNillableByteArray()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncBytesArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteByteArray(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableByteArray(o.Optional)

	return nil
}

type MyServiceFuncDatetimeArgs struct {
	Value    time.Time  `json:"value" yaml:"value" msgpack:"value"`
	Optional *time.Time `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncDatetimeArgs returns a `MyServiceFuncDatetimeArgs` struct
// populated with its default values.
func DefaultMyServiceFuncDatetimeArgs() MyServiceFuncDatetimeArgs {
	return MyServiceFuncDatetimeArgs{}
}

func (o *MyServiceFuncDatetimeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadTime()
		case "optional":
			o.Optional, err = decoder.ReadNillableTime()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncDatetimeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteTime(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableTime(o.Optional)

	return nil
}

type MyServiceFuncListArgs struct {
	Value    []string `json:"value" yaml:"value" msgpack:"value"`
	Optional []string `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncListArgs returns a `MyServiceFuncListArgs` struct populated
// with its default values.
func DefaultMyServiceFuncListArgs() MyServiceFuncListArgs {
	return MyServiceFuncListArgs{}
}

func (o *MyServiceFuncListArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadSlice(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		case "optional":
			o.Optional, err = msgpack.ReadSlice(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncListArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteArraySize(uint32(len(o.Value)))
	for _, v := range o.Value {
		encoder.WriteString(v)
	}
	encoder.WriteString("optional")
	encoder.WriteArraySize(uint32(len(o.Optional)))
	for _, v := range o.Optional {
		encoder.WriteString(v)
	}

	return nil
}

type MyServiceFuncMapArgs struct {
	Value    map[string]string `json:"value" yaml:"value" msgpack:"value"`
	Optional map[string]string `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncMapArgs returns a `MyServiceFuncMapArgs` struct populated
// with its default values.
func DefaultMyServiceFuncMapArgs() MyServiceFuncMapArgs {
	return MyServiceFuncMapArgs{}
}

func (o *MyServiceFuncMapArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadMap(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		case "optional":
			o.Optional, err = msgpack.ReadMap(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncMapArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteMapSize(uint32(len(o.Value)))
	if o.Value != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.Value {
			encoder.WriteString(k)
			encoder.WriteString(v)
		}
	}
	encoder.WriteString("optional")
	encoder.WriteMapSize(uint32(len(o.Optional)))
	if o.Optional != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.Optional {
			encoder.WriteString(k)
			encoder.WriteString(v)
		}
	}

	return nil
}

func (o *MyType) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "sameValue":
			o.SameValue, err = msgpack.DecodeNillable[MyType](decoder)
		case "typeValue":
			err = o.TypeValue.Decode(decoder)
		case "stringValue":
			o.StringValue, err = decoder.ReadString()
		case "stringOption":
			o.StringOption, err = decoder.ReadNillableString()
		case "i64Value":
			o.I64Value, err = decoder.ReadInt64()
		case "i64Option":
			o.I64Option, err = decoder.ReadNillableInt64()
		case "i32Value":
			o.I32Value, err = decoder.ReadInt32()
		case "i32Option":
			o.I32Option, err = decoder.ReadNillableInt32()
		case "i16Value":
			o.I16Value, err = decoder.ReadInt16()
		case "i16Option":
			o.I16Option, err = decoder.ReadNillableInt16()
		case "i8Value":
			o.I8Value, err = decoder.ReadInt8()
		case "i8Option":
			o.I8Option, err = decoder.ReadNillableInt8()
		case "u64Value":
			o.U64Value, err = decoder.ReadUint64()
		case "u64Option":
			o.U64Option, err = decoder.ReadNillableUint64()
		case "u32Value":
			o.U32Value, err = decoder.ReadUint32()
		case "u32Option":
			o.U32Option, err = decoder.ReadNillableUint32()
		case "u16Value":
			o.U16Value, err = decoder.ReadUint16()
		case "u16Option":
			o.U16Option, err = decoder.ReadNillableUint16()
		case "u8Value":
			o.U8Value, err = decoder.ReadUint8()
		case "u8Option":
			o.U8Option, err = decoder.ReadNillableUint8()
		case "f64Value":
			o.F64Value, err = decoder.ReadFloat64()
		case "f64Option":
			o.F64Option, err = decoder.ReadNillableFloat64()
		case "f32Value":
			o.F32Value, err = decoder.ReadFloat32()
		case "f32Option":
			o.F32Option, err = decoder.ReadNillableFloat32()
		case "datetimeValue":
			o.DatetimeValue, err = decoder.ReadTime()
		case "datetimeOption":
			o.DatetimeOption, err = decoder.ReadNillableTime()
		case "bytesValue":
			o.BytesValue, err = decoder.ReadByteArray()
		case "bytesOption":
			o.BytesOption, err = decoder.ReadNillableByteArray()
		case "mapValue":
			o.MapValue, err = msgpack.ReadMap(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (int64, error) {
				return decoder.ReadInt64()
			})
		case "mapOfTypes":
			o.MapOfTypes, err = msgpack.ReadMap(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (MyType, error) {
				return msgpack.Decode[MyType](decoder)
			})
		case "arrayValue":
			o.ArrayValue, err = msgpack.ReadSlice(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		case "arrayOfTypes":
			o.ArrayOfTypes, err = msgpack.ReadSlice(decoder, func(decoder msgpack.Reader) (MyType, error) {
				return msgpack.Decode[MyType](decoder)
			})
		case "unionValue":
			o.UnionValue, err = msgpack.Decode[MyUnion](decoder)
		case "unionOption":
			o.UnionOption, err = msgpack.DecodeNillable[MyUnion](decoder)
		case "enumValue":
			o.EnumValue, err = convert.Numeric[MyEnum](decoder.ReadInt32())
		case "enumOption":
			o.EnumOption, err = convert.NillableNumeric[MyEnum](decoder.ReadNillableInt32())
		case "aliasValue":
			o.AliasValue, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "aliasOption":
			o.AliasOption, err = convert.NillableParse(uuid.Parse)(decoder.ReadNillableString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyType) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(38)
	encoder.WriteString("sameValue")
	o.SameValue.Encode(encoder)
	encoder.WriteString("typeValue")
	o.TypeValue.Encode(encoder)
	encoder.WriteString("stringValue")
	encoder.WriteString(o.StringValue)
	encoder.WriteString("stringOption")
	encoder.WriteNillableString(o.StringOption)
	encoder.WriteString("i64Value")
	encoder.WriteInt64(o.I64Value)
	encoder.WriteString("i64Option")
	encoder.WriteNillableInt64(o.I64Option)
	encoder.WriteString("i32Value")
	encoder.WriteInt32(o.I32Value)
	encoder.WriteString("i32Option")
	encoder.WriteNillableInt32(o.I32Option)
	encoder.WriteString("i16Value")
	encoder.WriteInt16(o.I16Value)
	encoder.WriteString("i16Option")
	encoder.WriteNillableInt16(o.I16Option)
	encoder.WriteString("i8Value")
	encoder.WriteInt8(o.I8Value)
	encoder.WriteString("i8Option")
	encoder.WriteNillableInt8(o.I8Option)
	encoder.WriteString("u64Value")
	encoder.WriteUint64(o.U64Value)
	encoder.WriteString("u64Option")
	encoder.WriteNillableUint64(o.U64Option)
	encoder.WriteString("u32Value")
	encoder.WriteUint32(o.U32Value)
	encoder.WriteString("u32Option")
	encoder.WriteNillableUint32(o.U32Option)
	encoder.WriteString("u16Value")
	encoder.WriteUint16(o.U16Value)
	encoder.WriteString("u16Option")
	encoder.WriteNillableUint16(o.U16Option)
	encoder.WriteString("u8Value")
	encoder.WriteUint8(o.U8Value)
	encoder.WriteString("u8Option")
	encoder.WriteNillableUint8(o.U8Option)
	encoder.WriteString("f64Value")
	encoder.WriteFloat64(o.F64Value)
	encoder.WriteString("f64Option")
	encoder.WriteNillableFloat64(o.F64Option)
	encoder.WriteString("f32Value")
	encoder.WriteFloat32(o.F32Value)
	encoder.WriteString("f32Option")
	encoder.WriteNillableFloat32(o.F32Option)
	encoder.WriteString("datetimeValue")
	encoder.WriteTime(o.DatetimeValue)
	encoder.WriteString("datetimeOption")
	encoder.WriteNillableTime(o.DatetimeOption)
	encoder.WriteString("bytesValue")
	encoder.WriteByteArray(o.BytesValue)
	encoder.WriteString("bytesOption")
	encoder.WriteNillableByteArray(o.BytesOption)
	encoder.WriteString("mapValue")
	encoder.WriteMapSize(uint32(len(o.MapValue)))
	if o.MapValue != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.MapValue {
			encoder.WriteString(k)
			encoder.WriteInt64(v)
		}
	}
	encoder.WriteString("mapOfTypes")
	encoder.WriteMapSize(uint32(len(o.MapOfTypes)))
	if o.MapOfTypes != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.MapOfTypes {
			encoder.WriteString(k)
			v.Encode(encoder)
		}
	}
	encoder.WriteString("arrayValue")
	encoder.WriteArraySize(uint32(len(o.ArrayValue)))
	for _, v := range o.ArrayValue {
		encoder.WriteString(v)
	}
	encoder.WriteString("arrayOfTypes")
	encoder.WriteArraySize(uint32(len(o.ArrayOfTypes)))
	for _, v := range o.ArrayOfTypes {
		v.Encode(encoder)
	}
	encoder.WriteString("unionValue")
	o.UnionValue.Encode(encoder)
	encoder.WriteString("unionOption")
	if o.UnionOption == nil {
		encoder.WriteNil()
	} else {
		o.UnionOption.Encode(encoder)
	}
	encoder.WriteString("enumValue")
	encoder.WriteInt32(int32(o.EnumValue))
	encoder.WriteString("enumOption")
	encoder.WriteNillableInt32((*int32)(o.EnumOption))
	encoder.WriteString("aliasValue")
	encoder.WriteString(o.AliasValue.String())
	encoder.WriteString("aliasOption")
	if o.AliasOption == nil {
		encoder.WriteNil()
	} else {
		encoder.WriteString(o.AliasOption.String())
	}

	return nil
}

func (o *MyOtherType) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "foo":
			o.Foo, err = decoder.ReadString()
		case "bar":
			o.Bar, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyOtherType) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("foo")
	encoder.WriteString(o.Foo)
	encoder.WriteString("bar")
	encoder.WriteString(o.Bar)

	return nil
}

func (o *MyUnion) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "MyType":
			o.MyType, err = msgpack.DecodeNillable[MyType](decoder)
		case "MyEnum":
			o.MyEnum, err = convert.NillableNumeric[MyEnum](decoder.ReadNillableInt32())
		case "string":
			o.String, err = decoder.ReadNillableString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyUnion) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	if o.MyType != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("MyType")
		o.MyType.Encode(encoder)
		return nil
	}
	if o.MyEnum != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("MyEnum")
		encoder.WriteNillableInt32((*int32)(o.MyEnum))
		return nil
	}
	if o.String != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("string")
		encoder.WriteNillableString(o.String)
		return nil
	}

	encoder.WriteNil()
	return nil
}

type Dependencies struct {
	SomeCalc   SomeCalcFn
	MyStreamer MyStreamer
	MyService  MyService
}

type Client struct {
	caller                                  invoke.Caller
	_opSomeCalc                             uint32
	_opMyStreamerRequestStreamI64           uint32
	_opMyStreamerRequestStreamF64           uint32
	_opMyStreamerRequestStreamType          uint32
	_opMyStreamerRequestStreamEnum          uint32
	_opMyStreamerRequestStreamUUID          uint32
	_opMyStreamerRequestStreamAlias         uint32
	_opMyStreamerRequestStreamString        uint32
	_opMyStreamerRequestStreamBool          uint32
	_opMyStreamerRequestStreamDatetime      uint32
	_opMyStreamerRequestStreamList          uint32
	_opMyStreamerRequestStreamMap           uint32
	_opMyStreamerRequestStreamArgsI64       uint32
	_opMyStreamerRequestStreamArgsF64       uint32
	_opMyStreamerRequestStreamArgsType      uint32
	_opMyStreamerRequestStreamArgsEnum      uint32
	_opMyStreamerRequestStreamArgsUUID      uint32
	_opMyStreamerRequestStreamArgsAlias     uint32
	_opMyStreamerRequestStreamArgsString    uint32
	_opMyStreamerRequestStreamArgsBool      uint32
	_opMyStreamerRequestStreamArgsDatetime  uint32
	_opMyStreamerRequestStreamArgsList      uint32
	_opMyStreamerRequestStreamArgsMap       uint32
	_opMyStreamerRequestChannelVoid         uint32
	_opMyStreamerRequestChannelSingle       uint32
	_opMyStreamerRequestChannelI64          uint32
	_opMyStreamerRequestChannelF64          uint32
	_opMyStreamerRequestChannelType         uint32
	_opMyStreamerRequestChannelEnum         uint32
	_opMyStreamerRequestChannelAlias        uint32
	_opMyStreamerRequestChannelString       uint32
	_opMyStreamerRequestChannelBool         uint32
	_opMyStreamerRequestChannelDatetime     uint32
	_opMyStreamerRequestChannelList         uint32
	_opMyStreamerRequestChannelMap          uint32
	_opMyStreamerRequestChannelArgsSingle   uint32
	_opMyStreamerRequestChannelArgsI64      uint32
	_opMyStreamerRequestChannelArgsF64      uint32
	_opMyStreamerRequestChannelArgsType     uint32
	_opMyStreamerRequestChannelArgsEnum     uint32
	_opMyStreamerRequestChannelArgsAlias    uint32
	_opMyStreamerRequestChannelArgsString   uint32
	_opMyStreamerRequestChannelArgsBool     uint32
	_opMyStreamerRequestChannelArgsDatetime uint32
	_opMyStreamerRequestChannelArgsList     uint32
	_opMyStreamerRequestChannelArgsMap      uint32
	_opMyServiceEmptyVoid                   uint32
	_opMyServiceUnaryType                   uint32
	_opMyServiceUnaryEnum                   uint32
	_opMyServiceUnaryUUID                   uint32
	_opMyServiceUnaryAlias                  uint32
	_opMyServiceUnaryString                 uint32
	_opMyServiceUnaryI64                    uint32
	_opMyServiceUnaryI32                    uint32
	_opMyServiceUnaryI16                    uint32
	_opMyServiceUnaryI8                     uint32
	_opMyServiceUnaryU64                    uint32
	_opMyServiceUnaryU32                    uint32
	_opMyServiceUnaryU16                    uint32
	_opMyServiceUnaryU8                     uint32
	_opMyServiceUnaryF64                    uint32
	_opMyServiceUnaryF32                    uint32
	_opMyServiceUnaryBytes                  uint32
	_opMyServiceUnaryDatetime               uint32
	_opMyServiceUnaryList                   uint32
	_opMyServiceUnaryMap                    uint32
	_opMyServiceFuncType                    uint32
	_opMyServiceFuncEnum                    uint32
	_opMyServiceFuncUUID                    uint32
	_opMyServiceFuncAlias                   uint32
	_opMyServiceFuncString                  uint32
	_opMyServiceFuncI64                     uint32
	_opMyServiceFuncI32                     uint32
	_opMyServiceFuncI16                     uint32
	_opMyServiceFuncI8                      uint32
	_opMyServiceFuncU64                     uint32
	_opMyServiceFuncU32                     uint32
	_opMyServiceFuncU16                     uint32
	_opMyServiceFuncU8                      uint32
	_opMyServiceFuncF64                     uint32
	_opMyServiceFuncF32                     uint32
	_opMyServiceFuncBytes                   uint32
	_opMyServiceFuncDatetime                uint32
	_opMyServiceFuncList                    uint32
	_opMyServiceFuncMap                     uint32
}

func New(caller invoke.Caller) *Client {
	return &Client{
		caller:                                  caller,
		_opSomeCalc:                             invoke.ImportRequestResponse("iota.testing", "someCalc"),
		_opMyStreamerRequestStreamI64:           invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamI64"),
		_opMyStreamerRequestStreamF64:           invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamF64"),
		_opMyStreamerRequestStreamType:          invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamType"),
		_opMyStreamerRequestStreamEnum:          invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamEnum"),
		_opMyStreamerRequestStreamUUID:          invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamUUID"),
		_opMyStreamerRequestStreamAlias:         invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamAlias"),
		_opMyStreamerRequestStreamString:        invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamString"),
		_opMyStreamerRequestStreamBool:          invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamBool"),
		_opMyStreamerRequestStreamDatetime:      invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamDatetime"),
		_opMyStreamerRequestStreamList:          invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamList"),
		_opMyStreamerRequestStreamMap:           invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamMap"),
		_opMyStreamerRequestStreamArgsI64:       invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamArgsI64"),
		_opMyStreamerRequestStreamArgsF64:       invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamArgsF64"),
		_opMyStreamerRequestStreamArgsType:      invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamArgsType"),
		_opMyStreamerRequestStreamArgsEnum:      invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamArgsEnum"),
		_opMyStreamerRequestStreamArgsUUID:      invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamArgsUUID"),
		_opMyStreamerRequestStreamArgsAlias:     invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamArgsAlias"),
		_opMyStreamerRequestStreamArgsString:    invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamArgsString"),
		_opMyStreamerRequestStreamArgsBool:      invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamArgsBool"),
		_opMyStreamerRequestStreamArgsDatetime:  invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamArgsDatetime"),
		_opMyStreamerRequestStreamArgsList:      invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamArgsList"),
		_opMyStreamerRequestStreamArgsMap:       invoke.ImportRequestStream("iota.testing.MyStreamer", "requestStreamArgsMap"),
		_opMyStreamerRequestChannelVoid:         invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelVoid"),
		_opMyStreamerRequestChannelSingle:       invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelSingle"),
		_opMyStreamerRequestChannelI64:          invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelI64"),
		_opMyStreamerRequestChannelF64:          invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelF64"),
		_opMyStreamerRequestChannelType:         invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelType"),
		_opMyStreamerRequestChannelEnum:         invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelEnum"),
		_opMyStreamerRequestChannelAlias:        invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelAlias"),
		_opMyStreamerRequestChannelString:       invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelString"),
		_opMyStreamerRequestChannelBool:         invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelBool"),
		_opMyStreamerRequestChannelDatetime:     invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelDatetime"),
		_opMyStreamerRequestChannelList:         invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelList"),
		_opMyStreamerRequestChannelMap:          invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelMap"),
		_opMyStreamerRequestChannelArgsSingle:   invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsSingle"),
		_opMyStreamerRequestChannelArgsI64:      invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsI64"),
		_opMyStreamerRequestChannelArgsF64:      invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsF64"),
		_opMyStreamerRequestChannelArgsType:     invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsType"),
		_opMyStreamerRequestChannelArgsEnum:     invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsEnum"),
		_opMyStreamerRequestChannelArgsAlias:    invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsAlias"),
		_opMyStreamerRequestChannelArgsString:   invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsString"),
		_opMyStreamerRequestChannelArgsBool:     invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsBool"),
		_opMyStreamerRequestChannelArgsDatetime: invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsDatetime"),
		_opMyStreamerRequestChannelArgsList:     invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsList"),
		_opMyStreamerRequestChannelArgsMap:      invoke.ImportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsMap"),
		_opMyServiceEmptyVoid:                   invoke.ImportRequestResponse("iota.testing.MyService", "emptyVoid"),
		_opMyServiceUnaryType:                   invoke.ImportRequestResponse("iota.testing.MyService", "unaryType"),
		_opMyServiceUnaryEnum:                   invoke.ImportRequestResponse("iota.testing.MyService", "unaryEnum"),
		_opMyServiceUnaryUUID:                   invoke.ImportRequestResponse("iota.testing.MyService", "unaryUUID"),
		_opMyServiceUnaryAlias:                  invoke.ImportRequestResponse("iota.testing.MyService", "unaryAlias"),
		_opMyServiceUnaryString:                 invoke.ImportRequestResponse("iota.testing.MyService", "unaryString"),
		_opMyServiceUnaryI64:                    invoke.ImportRequestResponse("iota.testing.MyService", "unaryI64"),
		_opMyServiceUnaryI32:                    invoke.ImportRequestResponse("iota.testing.MyService", "unaryI32"),
		_opMyServiceUnaryI16:                    invoke.ImportRequestResponse("iota.testing.MyService", "unaryI16"),
		_opMyServiceUnaryI8:                     invoke.ImportRequestResponse("iota.testing.MyService", "unaryI8"),
		_opMyServiceUnaryU64:                    invoke.ImportRequestResponse("iota.testing.MyService", "unaryU64"),
		_opMyServiceUnaryU32:                    invoke.ImportRequestResponse("iota.testing.MyService", "unaryU32"),
		_opMyServiceUnaryU16:                    invoke.ImportRequestResponse("iota.testing.MyService", "unaryU16"),
		_opMyServiceUnaryU8:                     invoke.ImportRequestResponse("iota.testing.MyService", "unaryU8"),
		_opMyServiceUnaryF64:                    invoke.ImportRequestResponse("iota.testing.MyService", "unaryF64"),
		_opMyServiceUnaryF32:                    invoke.ImportRequestResponse("iota.testing.MyService", "unaryF32"),
		_opMyServiceUnaryBytes:                  invoke.ImportRequestResponse("iota.testing.MyService", "unaryBytes"),
		_opMyServiceUnaryDatetime:               invoke.ImportRequestResponse("iota.testing.MyService", "unaryDatetime"),
		_opMyServiceUnaryList:                   invoke.ImportRequestResponse("iota.testing.MyService", "unaryList"),
		_opMyServiceUnaryMap:                    invoke.ImportRequestResponse("iota.testing.MyService", "unaryMap"),
		_opMyServiceFuncType:                    invoke.ImportRequestResponse("iota.testing.MyService", "funcType"),
		_opMyServiceFuncEnum:                    invoke.ImportRequestResponse("iota.testing.MyService", "funcEnum"),
		_opMyServiceFuncUUID:                    invoke.ImportRequestResponse("iota.testing.MyService", "funcUUID"),
		_opMyServiceFuncAlias:                   invoke.ImportRequestResponse("iota.testing.MyService", "funcAlias"),
		_opMyServiceFuncString:                  invoke.ImportRequestResponse("iota.testing.MyService", "funcString"),
		_opMyServiceFuncI64:                     invoke.ImportRequestResponse("iota.testing.MyService", "funcI64"),
		_opMyServiceFuncI32:                     invoke.ImportRequestResponse("iota.testing.MyService", "funcI32"),
		_opMyServiceFuncI16:                     invoke.ImportRequestResponse("iota.testing.MyService", "funcI16"),
		_opMyServiceFuncI8:                      invoke.ImportRequestResponse("iota.testing.MyService", "funcI8"),
		_opMyServiceFuncU64:                     invoke.ImportRequestResponse("iota.testing.MyService", "funcU64"),
		_opMyServiceFuncU32:                     invoke.ImportRequestResponse("iota.testing.MyService", "funcU32"),
		_opMyServiceFuncU16:                     invoke.ImportRequestResponse("iota.testing.MyService", "funcU16"),
		_opMyServiceFuncU8:                      invoke.ImportRequestResponse("iota.testing.MyService", "funcU8"),
		_opMyServiceFuncF64:                     invoke.ImportRequestResponse("iota.testing.MyService", "funcF64"),
		_opMyServiceFuncF32:                     invoke.ImportRequestResponse("iota.testing.MyService", "funcF32"),
		_opMyServiceFuncBytes:                   invoke.ImportRequestResponse("iota.testing.MyService", "funcBytes"),
		_opMyServiceFuncDatetime:                invoke.ImportRequestResponse("iota.testing.MyService", "funcDatetime"),
		_opMyServiceFuncList:                    invoke.ImportRequestResponse("iota.testing.MyService", "funcList"),
		_opMyServiceFuncMap:                     invoke.ImportRequestResponse("iota.testing.MyService", "funcMap"),
	}
}
func (c *Client) Dependencies() Dependencies {
	return Dependencies{
		SomeCalc:   c.SomeCalc,
		MyStreamer: c.MyStreamer(),
		MyService:  c.MyService(),
	}
}

func GetDependencies(caller invoke.Caller) Dependencies {
	c := New(caller)
	return c.Dependencies()
}

func (c *Client) SomeCalc(ctx context.Context, rhs int64, lhs int64) mono.Mono[int64] {
	request := SomeCalcArgs{
		Rhs: rhs,
		Lhs: lhs,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[int64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], c._opSomeCalc)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Int64.Decode)
}

type MyStreamerClient struct {
	c          *Client
	instanceID uint64
}

func (c *Client) MyStreamer() MyStreamer {
	return &MyStreamerClient{
		c: c,
	}
}

func (m *MyStreamerClient) RequestStreamI64(ctx context.Context) flux.Flux[int64] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamI64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Int64.Decode)
}

func (m *MyStreamerClient) RequestStreamF64(ctx context.Context) flux.Flux[float64] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamF64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Float64.Decode)
}

func (m *MyStreamerClient) RequestStreamType(ctx context.Context) flux.Flux[MyType] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamType)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[MyType])
}

func (m *MyStreamerClient) RequestStreamEnum(ctx context.Context) flux.Flux[MyEnum] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamEnum)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Int32Decode[MyEnum])
}

func (m *MyStreamerClient) RequestStreamUUID(ctx context.Context) flux.Flux[uuid.UUID] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamUUID)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.ToStringDecode(func(val string) (uuid.UUID, error) {
		return uuid.Parse(val)
	}))
}

func (m *MyStreamerClient) RequestStreamAlias(ctx context.Context) flux.Flux[MyAlias] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamAlias)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.StringDecode[MyAlias])
}

func (m *MyStreamerClient) RequestStreamString(ctx context.Context) flux.Flux[string] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamString)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.String.Decode)
}

func (m *MyStreamerClient) RequestStreamBool(ctx context.Context) flux.Flux[bool] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamBool)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Bool.Decode)
}

func (m *MyStreamerClient) RequestStreamDatetime(ctx context.Context) flux.Flux[time.Time] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamDatetime)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Time.Decode)
}

func (m *MyStreamerClient) RequestStreamList(ctx context.Context) flux.Flux[[]string] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamList)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.SliceDecode(func(decoder msgpack.Reader) (string, error) {
		return decoder.ReadString()
	}))
}

func (m *MyStreamerClient) RequestStreamMap(ctx context.Context) flux.Flux[map[string]string] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamMap)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MapDecode(
		func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}, func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}))
}

func (m *MyStreamerClient) RequestStreamArgsI64(ctx context.Context, value int64) flux.Flux[int64] {
	request := MyStreamerRequestStreamArgsI64Args{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[int64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamArgsI64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Int64.Decode)
}

func (m *MyStreamerClient) RequestStreamArgsF64(ctx context.Context, value float64) flux.Flux[float64] {
	request := MyStreamerRequestStreamArgsF64Args{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[float64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamArgsF64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Float64.Decode)
}

func (m *MyStreamerClient) RequestStreamArgsType(ctx context.Context, value *MyType) flux.Flux[MyType] {
	request := MyStreamerRequestStreamArgsTypeArgs{
		Value: *value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[MyType](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamArgsType)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[MyType])
}

func (m *MyStreamerClient) RequestStreamArgsEnum(ctx context.Context, value MyEnum) flux.Flux[MyEnum] {
	request := MyStreamerRequestStreamArgsEnumArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[MyEnum](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamArgsEnum)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Int32Decode[MyEnum])
}

func (m *MyStreamerClient) RequestStreamArgsUUID(ctx context.Context, value uuid.UUID) flux.Flux[uuid.UUID] {
	request := MyStreamerRequestStreamArgsUUIDArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[uuid.UUID](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamArgsUUID)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.ToStringDecode(func(val string) (uuid.UUID, error) {
		return uuid.Parse(val)
	}))
}

func (m *MyStreamerClient) RequestStreamArgsAlias(ctx context.Context, value MyAlias) flux.Flux[MyAlias] {
	request := MyStreamerRequestStreamArgsAliasArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[MyAlias](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamArgsAlias)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.StringDecode[MyAlias])
}

func (m *MyStreamerClient) RequestStreamArgsString(ctx context.Context, value string) flux.Flux[string] {
	request := MyStreamerRequestStreamArgsStringArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamArgsString)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.String.Decode)
}

func (m *MyStreamerClient) RequestStreamArgsBool(ctx context.Context, value bool) flux.Flux[bool] {
	request := MyStreamerRequestStreamArgsBoolArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[bool](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamArgsBool)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Bool.Decode)
}

func (m *MyStreamerClient) RequestStreamArgsDatetime(ctx context.Context, value time.Time) flux.Flux[time.Time] {
	request := MyStreamerRequestStreamArgsDatetimeArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[time.Time](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamArgsDatetime)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Time.Decode)
}

func (m *MyStreamerClient) RequestStreamArgsList(ctx context.Context, value []string) flux.Flux[[]string] {
	request := MyStreamerRequestStreamArgsListArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[[]string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamArgsList)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.SliceDecode(func(decoder msgpack.Reader) (string, error) {
		return decoder.ReadString()
	}))
}

func (m *MyStreamerClient) RequestStreamArgsMap(ctx context.Context, value map[string]string) flux.Flux[map[string]string] {
	request := MyStreamerRequestStreamArgsMapArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[map[string]string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestStreamArgsMap)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MapDecode(
		func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}, func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}))
}

func (m *MyStreamerClient) RequestChannelVoid(ctx context.Context, in flux.Flux[int64]) mono.Void {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelVoid)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Int64.Encode))
	return transform.FluxToVoid(future)
}

func (m *MyStreamerClient) RequestChannelSingle(ctx context.Context, in flux.Flux[int64]) mono.Mono[int64] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelSingle)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	futureStream := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Int64.Encode))
	future := transform.FluxToMono(futureStream)
	return mono.Map(future, transform.Int64.Decode)
}

func (m *MyStreamerClient) RequestChannelI64(ctx context.Context, in flux.Flux[int64]) flux.Flux[int64] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelI64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Int64.Encode))
	return flux.Map(future, transform.Int64.Decode)
}

func (m *MyStreamerClient) RequestChannelF64(ctx context.Context, in flux.Flux[float64]) flux.Flux[float64] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelF64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Float64.Encode))
	return flux.Map(future, transform.Float64.Decode)
}

func (m *MyStreamerClient) RequestChannelType(ctx context.Context, in flux.Flux[MyType]) flux.Flux[MyType] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelType)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.MsgPackEncode[MyType]))
	return flux.Map(future, transform.MsgPackDecode[MyType])
}

func (m *MyStreamerClient) RequestChannelEnum(ctx context.Context, in flux.Flux[MyEnum]) flux.Flux[MyEnum] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelEnum)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Int32Encode[MyEnum]))
	return flux.Map(future, transform.Int32Decode[MyEnum])
}

func (m *MyStreamerClient) RequestChannelAlias(ctx context.Context, in flux.Flux[uuid.UUID]) flux.Flux[uuid.UUID] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelAlias)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.ToStringEncode(func(val uuid.UUID) string {
		return val.String()
	})))
	return flux.Map(future, transform.ToStringDecode(func(val string) (uuid.UUID, error) {
		return uuid.Parse(val)
	}))
}

func (m *MyStreamerClient) RequestChannelString(ctx context.Context, in flux.Flux[string]) flux.Flux[string] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelString)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.String.Encode))
	return flux.Map(future, transform.String.Decode)
}

func (m *MyStreamerClient) RequestChannelBool(ctx context.Context, in flux.Flux[bool]) flux.Flux[bool] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelBool)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Bool.Encode))
	return flux.Map(future, transform.Bool.Decode)
}

func (m *MyStreamerClient) RequestChannelDatetime(ctx context.Context, in flux.Flux[time.Time]) flux.Flux[time.Time] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelDatetime)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Time.Encode))
	return flux.Map(future, transform.Time.Decode)
}

func (m *MyStreamerClient) RequestChannelList(ctx context.Context, in flux.Flux[[]string]) flux.Flux[[]string] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelList)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.SliceEncode(func(writer msgpack.Writer, val string) {
		writer.WriteString(val)
	})))
	return flux.Map(future, transform.SliceDecode(func(decoder msgpack.Reader) (string, error) {
		return decoder.ReadString()
	}))
}

func (m *MyStreamerClient) RequestChannelMap(ctx context.Context, in flux.Flux[map[string]string]) flux.Flux[map[string]string] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelMap)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.MapEncode(func(writer msgpack.Writer, key string) {
		writer.WriteString(key)
	}, func(writer msgpack.Writer, val string) {
		writer.WriteString(val)
	})))
	return flux.Map(future, transform.MapDecode(
		func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}, func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}))
}

func (m *MyStreamerClient) RequestChannelArgsSingle(ctx context.Context, value int64, in flux.Flux[int64]) mono.Mono[int64] {
	request := MyStreamerRequestChannelArgsSingleArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[int64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelArgsSingle)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	futureStream := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Int64.Encode))
	future := transform.FluxToMono(futureStream)
	return mono.Map(future, transform.Int64.Decode)
}

func (m *MyStreamerClient) RequestChannelArgsI64(ctx context.Context, value int64, in flux.Flux[int64]) flux.Flux[int64] {
	request := MyStreamerRequestChannelArgsI64Args{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[int64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelArgsI64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Int64.Encode))
	return flux.Map(future, transform.Int64.Decode)
}

func (m *MyStreamerClient) RequestChannelArgsF64(ctx context.Context, value float64, in flux.Flux[float64]) flux.Flux[float64] {
	request := MyStreamerRequestChannelArgsF64Args{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[float64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelArgsF64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Float64.Encode))
	return flux.Map(future, transform.Float64.Decode)
}

func (m *MyStreamerClient) RequestChannelArgsType(ctx context.Context, value *MyType, in flux.Flux[MyType]) flux.Flux[MyType] {
	request := MyStreamerRequestChannelArgsTypeArgs{
		Value: *value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[MyType](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelArgsType)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.MsgPackEncode[MyType]))
	return flux.Map(future, transform.MsgPackDecode[MyType])
}

func (m *MyStreamerClient) RequestChannelArgsEnum(ctx context.Context, value MyEnum, in flux.Flux[MyEnum]) flux.Flux[MyEnum] {
	request := MyStreamerRequestChannelArgsEnumArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[MyEnum](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelArgsEnum)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Int32Encode[MyEnum]))
	return flux.Map(future, transform.Int32Decode[MyEnum])
}

func (m *MyStreamerClient) RequestChannelArgsAlias(ctx context.Context, value uuid.UUID, in flux.Flux[uuid.UUID]) flux.Flux[uuid.UUID] {
	request := MyStreamerRequestChannelArgsAliasArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[uuid.UUID](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelArgsAlias)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.ToStringEncode(func(val uuid.UUID) string {
		return val.String()
	})))
	return flux.Map(future, transform.ToStringDecode(func(val string) (uuid.UUID, error) {
		return uuid.Parse(val)
	}))
}

func (m *MyStreamerClient) RequestChannelArgsString(ctx context.Context, value string, in flux.Flux[string]) flux.Flux[string] {
	request := MyStreamerRequestChannelArgsStringArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelArgsString)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.String.Encode))
	return flux.Map(future, transform.String.Decode)
}

func (m *MyStreamerClient) RequestChannelArgsBool(ctx context.Context, value bool, in flux.Flux[bool]) flux.Flux[bool] {
	request := MyStreamerRequestChannelArgsBoolArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[bool](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelArgsBool)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Bool.Encode))
	return flux.Map(future, transform.Bool.Decode)
}

func (m *MyStreamerClient) RequestChannelArgsDatetime(ctx context.Context, value time.Time, in flux.Flux[time.Time]) flux.Flux[time.Time] {
	request := MyStreamerRequestChannelArgsDatetimeArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[time.Time](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelArgsDatetime)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Time.Encode))
	return flux.Map(future, transform.Time.Decode)
}

func (m *MyStreamerClient) RequestChannelArgsList(ctx context.Context, value []string, in flux.Flux[[]string]) flux.Flux[[]string] {
	request := MyStreamerRequestChannelArgsListArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[[]string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelArgsList)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.SliceEncode(func(writer msgpack.Writer, val string) {
		writer.WriteString(val)
	})))
	return flux.Map(future, transform.SliceDecode(func(decoder msgpack.Reader) (string, error) {
		return decoder.ReadString()
	}))
}

func (m *MyStreamerClient) RequestChannelArgsMap(ctx context.Context, value map[string]string, in flux.Flux[map[string]string]) flux.Flux[map[string]string] {
	request := MyStreamerRequestChannelArgsMapArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[map[string]string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyStreamerRequestChannelArgsMap)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.MapEncode(func(writer msgpack.Writer, key string) {
		writer.WriteString(key)
	}, func(writer msgpack.Writer, val string) {
		writer.WriteString(val)
	})))
	return flux.Map(future, transform.MapDecode(
		func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}, func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}))
}

type MyServiceClient struct {
	c          *Client
	instanceID uint64
}

func (c *Client) MyService() MyService {
	return &MyServiceClient{
		c: c,
	}
}

func (m *MyServiceClient) EmptyVoid(ctx context.Context) mono.Void {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceEmptyVoid)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Void.Decode)
}

func (m *MyServiceClient) UnaryType(ctx context.Context, value *MyType) mono.Mono[MyType] {
	payloadData, err := msgpack.ToBytes(value)
	if err != nil {
		return mono.Error[MyType](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryType)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[MyType])
}

func (m *MyServiceClient) UnaryEnum(ctx context.Context, value MyEnum) mono.Mono[MyEnum] {
	payloadData, err := msgpack.I32ToBytes(int32(value))
	if err != nil {
		return mono.Error[MyEnum](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryEnum)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Int32Decode[MyEnum])
}

func (m *MyServiceClient) UnaryUUID(ctx context.Context, value uuid.UUID) mono.Mono[uuid.UUID] {
	payloadData, err := msgpack.StringToBytes(value.String())
	if err != nil {
		return mono.Error[uuid.UUID](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryUUID)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.ToStringDecode(func(val string) (uuid.UUID, error) {
		return uuid.Parse(val)
	}))
}

func (m *MyServiceClient) UnaryAlias(ctx context.Context, value MyAlias) mono.Mono[MyAlias] {
	payloadData, err := msgpack.StringToBytes(string(value))
	if err != nil {
		return mono.Error[MyAlias](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryAlias)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.StringDecode[MyAlias])
}

func (m *MyServiceClient) UnaryString(ctx context.Context, value string) mono.Mono[string] {
	payloadData, err := msgpack.StringToBytes(value)
	if err != nil {
		return mono.Error[string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryString)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.String.Decode)
}

func (m *MyServiceClient) UnaryI64(ctx context.Context, value int64) mono.Mono[int64] {
	payloadData, err := msgpack.I64ToBytes(value)
	if err != nil {
		return mono.Error[int64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryI64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Int64.Decode)
}

func (m *MyServiceClient) UnaryI32(ctx context.Context, value int32) mono.Mono[int32] {
	payloadData, err := msgpack.I32ToBytes(value)
	if err != nil {
		return mono.Error[int32](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryI32)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Int32.Decode)
}

func (m *MyServiceClient) UnaryI16(ctx context.Context, value int16) mono.Mono[int16] {
	payloadData, err := msgpack.I16ToBytes(value)
	if err != nil {
		return mono.Error[int16](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryI16)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Int16.Decode)
}

func (m *MyServiceClient) UnaryI8(ctx context.Context, value int8) mono.Mono[int8] {
	payloadData, err := msgpack.I8ToBytes(value)
	if err != nil {
		return mono.Error[int8](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryI8)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Int8.Decode)
}

func (m *MyServiceClient) UnaryU64(ctx context.Context, value uint64) mono.Mono[uint64] {
	payloadData, err := msgpack.U64ToBytes(value)
	if err != nil {
		return mono.Error[uint64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryU64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Uint64.Decode)
}

func (m *MyServiceClient) UnaryU32(ctx context.Context, value uint32) mono.Mono[uint32] {
	payloadData, err := msgpack.U32ToBytes(value)
	if err != nil {
		return mono.Error[uint32](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryU32)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Uint32.Decode)
}

func (m *MyServiceClient) UnaryU16(ctx context.Context, value uint16) mono.Mono[uint16] {
	payloadData, err := msgpack.U16ToBytes(value)
	if err != nil {
		return mono.Error[uint16](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryU16)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Uint16.Decode)
}

func (m *MyServiceClient) UnaryU8(ctx context.Context, value uint8) mono.Mono[uint8] {
	payloadData, err := msgpack.U8ToBytes(value)
	if err != nil {
		return mono.Error[uint8](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryU8)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Uint8.Decode)
}

func (m *MyServiceClient) UnaryF64(ctx context.Context, value float64) mono.Mono[float64] {
	payloadData, err := msgpack.F64ToBytes(value)
	if err != nil {
		return mono.Error[float64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryF64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Float64.Decode)
}

func (m *MyServiceClient) UnaryF32(ctx context.Context, value float32) mono.Mono[float32] {
	payloadData, err := msgpack.F32ToBytes(value)
	if err != nil {
		return mono.Error[float32](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryF32)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Float32.Decode)
}

func (m *MyServiceClient) UnaryBytes(ctx context.Context, value []byte) mono.Mono[[]byte] {
	payloadData, err := msgpack.BytesToBytes(value)
	if err != nil {
		return mono.Error[[]byte](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryBytes)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Bytes.Decode)
}

func (m *MyServiceClient) UnaryDatetime(ctx context.Context, value time.Time) mono.Mono[time.Time] {
	payloadData, err := msgpack.TimeToBytes(value)
	if err != nil {
		return mono.Error[time.Time](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryDatetime)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Time.Decode)
}

func (m *MyServiceClient) UnaryList(ctx context.Context, value []string) mono.Mono[[]string] {
	payloadData, err := msgpack.SliceToBytes(value, func(writer msgpack.Writer, val string) {
		writer.WriteString(val)
	})
	if err != nil {
		return mono.Error[[]string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryList)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.SliceDecode(func(decoder msgpack.Reader) (string, error) {
		return decoder.ReadString()
	}))
}

func (m *MyServiceClient) UnaryMap(ctx context.Context, value map[string]string) mono.Mono[map[string]string] {
	payloadData, err := msgpack.MapToBytes(value, func(writer msgpack.Writer, val string) {
		writer.WriteString(val)
	}, func(writer msgpack.Writer, val string) {
		writer.WriteString(val)
	})
	if err != nil {
		return mono.Error[map[string]string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceUnaryMap)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MapDecode(
		func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}, func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}))
}

func (m *MyServiceClient) FuncType(ctx context.Context, value *MyType, optional *MyType) mono.Mono[MyType] {
	request := MyServiceFuncTypeArgs{
		Value:    *value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[MyType](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncType)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MsgPackDecode[MyType])
}

func (m *MyServiceClient) FuncEnum(ctx context.Context, value MyEnum, optional *MyEnum) mono.Mono[MyEnum] {
	request := MyServiceFuncEnumArgs{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[MyEnum](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncEnum)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Int32Decode[MyEnum])
}

func (m *MyServiceClient) FuncUUID(ctx context.Context, value uuid.UUID, optional *uuid.UUID) mono.Mono[uuid.UUID] {
	request := MyServiceFuncUUIDArgs{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[uuid.UUID](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncUUID)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.ToStringDecode(func(val string) (uuid.UUID, error) {
		return uuid.Parse(val)
	}))
}

func (m *MyServiceClient) FuncAlias(ctx context.Context, value MyAlias, optional *MyAlias) mono.Mono[MyAlias] {
	request := MyServiceFuncAliasArgs{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[MyAlias](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncAlias)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.StringDecode[MyAlias])
}

func (m *MyServiceClient) FuncString(ctx context.Context, value string, optional *string) mono.Mono[string] {
	request := MyServiceFuncStringArgs{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncString)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.String.Decode)
}

func (m *MyServiceClient) FuncI64(ctx context.Context, value int64, optional *int64) mono.Mono[int64] {
	request := MyServiceFuncI64Args{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[int64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncI64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Int64.Decode)
}

func (m *MyServiceClient) FuncI32(ctx context.Context, value int32, optional *int32) mono.Mono[int32] {
	request := MyServiceFuncI32Args{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[int32](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncI32)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Int32.Decode)
}

func (m *MyServiceClient) FuncI16(ctx context.Context, value int16, optional *int16) mono.Mono[int16] {
	request := MyServiceFuncI16Args{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[int16](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncI16)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Int16.Decode)
}

func (m *MyServiceClient) FuncI8(ctx context.Context, value int8, optional *int8) mono.Mono[int8] {
	request := MyServiceFuncI8Args{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[int8](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncI8)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Int8.Decode)
}

func (m *MyServiceClient) FuncU64(ctx context.Context, value uint64, optional *uint64) mono.Mono[uint64] {
	request := MyServiceFuncU64Args{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[uint64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncU64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Uint64.Decode)
}

func (m *MyServiceClient) FuncU32(ctx context.Context, value uint32, optional *uint32) mono.Mono[uint32] {
	request := MyServiceFuncU32Args{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[uint32](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncU32)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Uint32.Decode)
}

func (m *MyServiceClient) FuncU16(ctx context.Context, value uint16, optional *uint16) mono.Mono[uint16] {
	request := MyServiceFuncU16Args{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[uint16](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncU16)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Uint16.Decode)
}

func (m *MyServiceClient) FuncU8(ctx context.Context, value uint8, optional *uint8) mono.Mono[uint8] {
	request := MyServiceFuncU8Args{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[uint8](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncU8)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Uint8.Decode)
}

func (m *MyServiceClient) FuncF64(ctx context.Context, value float64, optional *float64) mono.Mono[float64] {
	request := MyServiceFuncF64Args{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[float64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncF64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Float64.Decode)
}

func (m *MyServiceClient) FuncF32(ctx context.Context, value float32, optional *float32) mono.Mono[float32] {
	request := MyServiceFuncF32Args{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[float32](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncF32)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Float32.Decode)
}

func (m *MyServiceClient) FuncBytes(ctx context.Context, value []byte, optional []byte) mono.Mono[[]byte] {
	request := MyServiceFuncBytesArgs{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[[]byte](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncBytes)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Bytes.Decode)
}

func (m *MyServiceClient) FuncDatetime(ctx context.Context, value time.Time, optional *time.Time) mono.Mono[time.Time] {
	request := MyServiceFuncDatetimeArgs{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[time.Time](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncDatetime)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.Time.Decode)
}

func (m *MyServiceClient) FuncList(ctx context.Context, value []string, optional []string) mono.Mono[[]string] {
	request := MyServiceFuncListArgs{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[[]string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncList)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.SliceDecode(func(decoder msgpack.Reader) (string, error) {
		return decoder.ReadString()
	}))
}

func (m *MyServiceClient) FuncMap(ctx context.Context, value map[string]string, optional map[string]string) mono.Mono[map[string]string] {
	request := MyServiceFuncMapArgs{
		Value:    value,
		Optional: optional,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return mono.Error[map[string]string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], m.c._opMyServiceFuncMap)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := m.c.caller.RequestResponse(ctx, pl)
	return mono.Map(future, transform.MapDecode(
		func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}, func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}))
}
