// Code generated by @apexlang/codegen. DO NOT EDIT.

package iotatest

import (
	"context"
	"errors"
	"time"

	"github.com/google/uuid"
	"github.com/nanobus/iota/go/rx/flux"
	"github.com/nanobus/iota/go/rx/mono"
)

type MyAlias string

type SomeCalcFn func(ctx context.Context, rhs int64, lhs int64) mono.Mono[int64]

type MyStreamer interface {
	RequestStreamI64(ctx context.Context) flux.Flux[int64]
	RequestStreamF64(ctx context.Context) flux.Flux[float64]
	RequestStreamType(ctx context.Context) flux.Flux[MyType]
	RequestStreamEnum(ctx context.Context) flux.Flux[MyEnum]
	RequestStreamUUID(ctx context.Context) flux.Flux[uuid.UUID]
	RequestStreamAlias(ctx context.Context) flux.Flux[MyAlias]
	RequestStreamString(ctx context.Context) flux.Flux[string]
	RequestStreamBool(ctx context.Context) flux.Flux[bool]
	RequestStreamDatetime(ctx context.Context) flux.Flux[time.Time]
	RequestStreamList(ctx context.Context) flux.Flux[[]string]
	RequestStreamMap(ctx context.Context) flux.Flux[map[string]string]
	RequestStreamArgsI64(ctx context.Context, value int64) flux.Flux[int64]
	RequestStreamArgsF64(ctx context.Context, value float64) flux.Flux[float64]
	RequestStreamArgsType(ctx context.Context, value *MyType) flux.Flux[MyType]
	RequestStreamArgsEnum(ctx context.Context, value MyEnum) flux.Flux[MyEnum]
	RequestStreamArgsUUID(ctx context.Context, value uuid.UUID) flux.Flux[uuid.UUID]
	RequestStreamArgsAlias(ctx context.Context, value MyAlias) flux.Flux[MyAlias]
	RequestStreamArgsString(ctx context.Context, value string) flux.Flux[string]
	RequestStreamArgsBool(ctx context.Context, value bool) flux.Flux[bool]
	RequestStreamArgsDatetime(ctx context.Context, value time.Time) flux.Flux[time.Time]
	RequestStreamArgsList(ctx context.Context, value []string) flux.Flux[[]string]
	RequestStreamArgsMap(ctx context.Context, value map[string]string) flux.Flux[map[string]string]
	RequestChannelVoid(ctx context.Context, in flux.Flux[int64]) mono.Void
	RequestChannelSingle(ctx context.Context, in flux.Flux[int64]) mono.Mono[int64]
	RequestChannelI64(ctx context.Context, in flux.Flux[int64]) flux.Flux[int64]
	RequestChannelF64(ctx context.Context, in flux.Flux[float64]) flux.Flux[float64]
	RequestChannelType(ctx context.Context, in flux.Flux[MyType]) flux.Flux[MyType]
	RequestChannelEnum(ctx context.Context, in flux.Flux[MyEnum]) flux.Flux[MyEnum]
	RequestChannelAlias(ctx context.Context, in flux.Flux[uuid.UUID]) flux.Flux[uuid.UUID]
	RequestChannelString(ctx context.Context, in flux.Flux[string]) flux.Flux[string]
	RequestChannelBool(ctx context.Context, in flux.Flux[bool]) flux.Flux[bool]
	RequestChannelDatetime(ctx context.Context, in flux.Flux[time.Time]) flux.Flux[time.Time]
	RequestChannelList(ctx context.Context, in flux.Flux[[]string]) flux.Flux[[]string]
	RequestChannelMap(ctx context.Context, in flux.Flux[map[string]string]) flux.Flux[map[string]string]
	RequestChannelArgsSingle(ctx context.Context, value int64, in flux.Flux[int64]) mono.Mono[int64]
	RequestChannelArgsI64(ctx context.Context, value int64, in flux.Flux[int64]) flux.Flux[int64]
	RequestChannelArgsF64(ctx context.Context, value float64, in flux.Flux[float64]) flux.Flux[float64]
	RequestChannelArgsType(ctx context.Context, value *MyType, in flux.Flux[MyType]) flux.Flux[MyType]
	RequestChannelArgsEnum(ctx context.Context, value MyEnum, in flux.Flux[MyEnum]) flux.Flux[MyEnum]
	RequestChannelArgsAlias(ctx context.Context, value uuid.UUID, in flux.Flux[uuid.UUID]) flux.Flux[uuid.UUID]
	RequestChannelArgsString(ctx context.Context, value string, in flux.Flux[string]) flux.Flux[string]
	RequestChannelArgsBool(ctx context.Context, value bool, in flux.Flux[bool]) flux.Flux[bool]
	RequestChannelArgsDatetime(ctx context.Context, value time.Time, in flux.Flux[time.Time]) flux.Flux[time.Time]
	RequestChannelArgsList(ctx context.Context, value []string, in flux.Flux[[]string]) flux.Flux[[]string]
	RequestChannelArgsMap(ctx context.Context, value map[string]string, in flux.Flux[map[string]string]) flux.Flux[map[string]string]
}

type MyService interface {
	EmptyVoid(ctx context.Context) mono.Void
	UnaryType(ctx context.Context, value *MyType) mono.Mono[MyType]
	UnaryEnum(ctx context.Context, value MyEnum) mono.Mono[MyEnum]
	UnaryUUID(ctx context.Context, value uuid.UUID) mono.Mono[uuid.UUID]
	UnaryAlias(ctx context.Context, value MyAlias) mono.Mono[MyAlias]
	UnaryString(ctx context.Context, value string) mono.Mono[string]
	UnaryI64(ctx context.Context, value int64) mono.Mono[int64]
	UnaryI32(ctx context.Context, value int32) mono.Mono[int32]
	UnaryI16(ctx context.Context, value int16) mono.Mono[int16]
	UnaryI8(ctx context.Context, value int8) mono.Mono[int8]
	UnaryU64(ctx context.Context, value uint64) mono.Mono[uint64]
	UnaryU32(ctx context.Context, value uint32) mono.Mono[uint32]
	UnaryU16(ctx context.Context, value uint16) mono.Mono[uint16]
	UnaryU8(ctx context.Context, value uint8) mono.Mono[uint8]
	UnaryF64(ctx context.Context, value float64) mono.Mono[float64]
	UnaryF32(ctx context.Context, value float32) mono.Mono[float32]
	UnaryBytes(ctx context.Context, value []byte) mono.Mono[[]byte]
	UnaryDatetime(ctx context.Context, value time.Time) mono.Mono[time.Time]
	UnaryList(ctx context.Context, value []string) mono.Mono[[]string]
	UnaryMap(ctx context.Context, value map[string]string) mono.Mono[map[string]string]
	FuncType(ctx context.Context, value *MyType, optional *MyType) mono.Mono[MyType]
	FuncEnum(ctx context.Context, value MyEnum, optional *MyEnum) mono.Mono[MyEnum]
	FuncUUID(ctx context.Context, value uuid.UUID, optional *uuid.UUID) mono.Mono[uuid.UUID]
	FuncAlias(ctx context.Context, value MyAlias, optional *MyAlias) mono.Mono[MyAlias]
	FuncString(ctx context.Context, value string, optional *string) mono.Mono[string]
	FuncI64(ctx context.Context, value int64, optional *int64) mono.Mono[int64]
	FuncI32(ctx context.Context, value int32, optional *int32) mono.Mono[int32]
	FuncI16(ctx context.Context, value int16, optional *int16) mono.Mono[int16]
	FuncI8(ctx context.Context, value int8, optional *int8) mono.Mono[int8]
	FuncU64(ctx context.Context, value uint64, optional *uint64) mono.Mono[uint64]
	FuncU32(ctx context.Context, value uint32, optional *uint32) mono.Mono[uint32]
	FuncU16(ctx context.Context, value uint16, optional *uint16) mono.Mono[uint16]
	FuncU8(ctx context.Context, value uint8, optional *uint8) mono.Mono[uint8]
	FuncF64(ctx context.Context, value float64, optional *float64) mono.Mono[float64]
	FuncF32(ctx context.Context, value float32, optional *float32) mono.Mono[float32]
	FuncBytes(ctx context.Context, value []byte, optional []byte) mono.Mono[[]byte]
	FuncDatetime(ctx context.Context, value time.Time, optional *time.Time) mono.Mono[time.Time]
	FuncList(ctx context.Context, value []string, optional []string) mono.Mono[[]string]
	FuncMap(ctx context.Context, value map[string]string, optional map[string]string) mono.Mono[map[string]string]
}

type Repository interface {
	GetData(ctx context.Context) mono.Mono[MyType]
}

// MyType is a class
type MyType struct {
	// same type value
	SameValue *MyType `json:"sameValue,omitempty" yaml:"sameValue,omitempty" msgpack:"sameValue,omitempty"`
	// type value
	TypeValue MyOtherType `json:"typeValue" yaml:"typeValue" msgpack:"typeValue"`
	// string value
	StringValue string `json:"stringValue" yaml:"stringValue" msgpack:"stringValue"`
	// string option
	StringOption *string `json:"stringOption,omitempty" yaml:"stringOption,omitempty" msgpack:"stringOption,omitempty"`
	// i64 value
	I64Value int64 `json:"i64Value" yaml:"i64Value" msgpack:"i64Value"`
	// i64 option
	I64Option *int64 `json:"i64Option,omitempty" yaml:"i64Option,omitempty" msgpack:"i64Option,omitempty"`
	// i32 value
	I32Value int32 `json:"i32Value" yaml:"i32Value" msgpack:"i32Value"`
	// i32 option
	I32Option *int32 `json:"i32Option,omitempty" yaml:"i32Option,omitempty" msgpack:"i32Option,omitempty"`
	// i16 value
	I16Value int16 `json:"i16Value" yaml:"i16Value" msgpack:"i16Value"`
	// i16 option
	I16Option *int16 `json:"i16Option,omitempty" yaml:"i16Option,omitempty" msgpack:"i16Option,omitempty"`
	// i8 value
	I8Value int8 `json:"i8Value" yaml:"i8Value" msgpack:"i8Value"`
	// i8 option
	I8Option *int8 `json:"i8Option,omitempty" yaml:"i8Option,omitempty" msgpack:"i8Option,omitempty"`
	// u64 value
	U64Value uint64 `json:"u64Value" yaml:"u64Value" msgpack:"u64Value"`
	// u64 option
	U64Option *uint64 `json:"u64Option,omitempty" yaml:"u64Option,omitempty" msgpack:"u64Option,omitempty"`
	// u32 value
	U32Value uint32 `json:"u32Value" yaml:"u32Value" msgpack:"u32Value"`
	// u32 option
	U32Option *uint32 `json:"u32Option,omitempty" yaml:"u32Option,omitempty" msgpack:"u32Option,omitempty"`
	// u16 value
	U16Value uint16 `json:"u16Value" yaml:"u16Value" msgpack:"u16Value"`
	// u16 option
	U16Option *uint16 `json:"u16Option,omitempty" yaml:"u16Option,omitempty" msgpack:"u16Option,omitempty"`
	// u8 value
	U8Value uint8 `json:"u8Value" yaml:"u8Value" msgpack:"u8Value"`
	// u8 option
	U8Option *uint8 `json:"u8Option,omitempty" yaml:"u8Option,omitempty" msgpack:"u8Option,omitempty"`
	// f64 value
	F64Value float64 `json:"f64Value" yaml:"f64Value" msgpack:"f64Value"`
	// f64 option
	F64Option *float64 `json:"f64Option,omitempty" yaml:"f64Option,omitempty" msgpack:"f64Option,omitempty"`
	// f32 value
	F32Value float32 `json:"f32Value" yaml:"f32Value" msgpack:"f32Value"`
	// f32 option
	F32Option *float32 `json:"f32Option,omitempty" yaml:"f32Option,omitempty" msgpack:"f32Option,omitempty"`
	// datetime value
	DatetimeValue time.Time `json:"datetimeValue" yaml:"datetimeValue" msgpack:"datetimeValue"`
	// datetime option
	DatetimeOption *time.Time `json:"datetimeOption,omitempty" yaml:"datetimeOption,omitempty" msgpack:"datetimeOption,omitempty"`
	// bytes value
	BytesValue []byte `json:"bytesValue" yaml:"bytesValue" msgpack:"bytesValue"`
	// bytes option
	BytesOption []byte `json:"bytesOption,omitempty" yaml:"bytesOption,omitempty" msgpack:"bytesOption,omitempty"`
	// map value
	MapValue map[string]int64 `json:"mapValue" yaml:"mapValue" msgpack:"mapValue"`
	// map of types
	MapOfTypes map[string]MyType `json:"mapOfTypes" yaml:"mapOfTypes" msgpack:"mapOfTypes"`
	// array value
	ArrayValue []string `json:"arrayValue" yaml:"arrayValue" msgpack:"arrayValue"`
	// array of types
	ArrayOfTypes []MyType `json:"arrayOfTypes" yaml:"arrayOfTypes" msgpack:"arrayOfTypes"`
	// union value
	UnionValue MyUnion `json:"unionValue" yaml:"unionValue" msgpack:"unionValue"`
	// union option
	UnionOption *MyUnion `json:"unionOption,omitempty" yaml:"unionOption,omitempty" msgpack:"unionOption,omitempty"`
	// enum value
	EnumValue MyEnum `json:"enumValue" yaml:"enumValue" msgpack:"enumValue"`
	// enum option
	EnumOption *MyEnum `json:"enumOption,omitempty" yaml:"enumOption,omitempty" msgpack:"enumOption,omitempty"`
	// enum value
	AliasValue uuid.UUID `json:"aliasValue" yaml:"aliasValue" msgpack:"aliasValue"`
	// enum option
	AliasOption *uuid.UUID `json:"aliasOption,omitempty" yaml:"aliasOption,omitempty" msgpack:"aliasOption,omitempty"`
}

// DefaultMyType returns a `MyType` struct populated with its default values.
func DefaultMyType() MyType {
	return MyType{}
}

type MyOtherType struct {
	Foo string `json:"foo" yaml:"foo" msgpack:"foo"`
	Bar string `json:"bar" yaml:"bar" msgpack:"bar"`
}

// DefaultMyOtherType returns a `MyOtherType` struct populated with its default
// values.
func DefaultMyOtherType() MyOtherType {
	return MyOtherType{}
}

type MyUnion struct {
	MyType *MyType `json:"MyType,omitempty" yaml:"MyType,omitempty" msgpack:"MyType,omitempty"`
	MyEnum *MyEnum `json:"MyEnum,omitempty" yaml:"MyEnum,omitempty" msgpack:"MyEnum,omitempty"`
	String *string `json:"string,omitempty" yaml:"string,omitempty" msgpack:"string,omitempty"`
}

// MyEnum is an emuneration
type MyEnum int32

const (
	// ONE value
	MyEnumOne MyEnum = 0
	// TWO value
	MyEnumTwo MyEnum = 1
	// THREE value
	MyEnumThree MyEnum = 2
)

var toStringMyEnum = map[MyEnum]string{
	MyEnumOne:   "one",
	MyEnumTwo:   "TWO",
	MyEnumThree: "three",
}

var toIDMyEnum = map[string]MyEnum{
	"one":   MyEnumOne,
	"TWO":   MyEnumTwo,
	"three": MyEnumThree,
}

func (e MyEnum) String() string {
	str, ok := toStringMyEnum[e]
	if !ok {
		return "unknown"
	}
	return str
}

func (e *MyEnum) FromString(str string) error {
	var ok bool
	*e, ok = toIDMyEnum[str]
	if !ok {
		return errors.New("unknown value \"" + str + "\" for MyEnum")
	}
	return nil
}
