// Code generated by @apexlang/codegen. DO NOT EDIT.

package iotatest

import (
	"context"
	"encoding/binary"
	"time"

	"github.com/google/uuid"
	"github.com/nanobus/iota/go/invoke"
	"github.com/nanobus/iota/go/msgpack"
	"github.com/nanobus/iota/go/msgpack/convert"
	"github.com/nanobus/iota/go/payload"
	"github.com/nanobus/iota/go/proxy"
	"github.com/nanobus/iota/go/rx/flux"
	"github.com/nanobus/iota/go/rx/mono"
	"github.com/nanobus/iota/go/transform"
)

type SomeCalcArgs struct {
	Rhs int64 `json:"rhs" yaml:"rhs" msgpack:"rhs"`
	Lhs int64 `json:"lhs" yaml:"lhs" msgpack:"lhs"`
}

// DefaultSomeCalcArgs returns a `SomeCalcArgs` struct populated with its default
// values.
func DefaultSomeCalcArgs() SomeCalcArgs {
	return SomeCalcArgs{}
}

func (o *SomeCalcArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "rhs":
			o.Rhs, err = decoder.ReadInt64()
		case "lhs":
			o.Lhs, err = decoder.ReadInt64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *SomeCalcArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("rhs")
	encoder.WriteInt64(o.Rhs)
	encoder.WriteString("lhs")
	encoder.WriteInt64(o.Lhs)

	return nil
}

type MyStreamerRequestStreamArgsI64Args struct {
	Value int64 `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsI64Args returns a
// `MyStreamerRequestStreamArgsI64Args` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsI64Args() MyStreamerRequestStreamArgsI64Args {
	return MyStreamerRequestStreamArgsI64Args{}
}

func (o *MyStreamerRequestStreamArgsI64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsI64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteInt64(o.Value)

	return nil
}

type MyStreamerRequestStreamArgsF64Args struct {
	Value float64 `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsF64Args returns a
// `MyStreamerRequestStreamArgsF64Args` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsF64Args() MyStreamerRequestStreamArgsF64Args {
	return MyStreamerRequestStreamArgsF64Args{}
}

func (o *MyStreamerRequestStreamArgsF64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadFloat64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsF64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteFloat64(o.Value)

	return nil
}

type MyStreamerRequestStreamArgsTypeArgs struct {
	Value MyType `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsTypeArgs returns a
// `MyStreamerRequestStreamArgsTypeArgs` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsTypeArgs() MyStreamerRequestStreamArgsTypeArgs {
	return MyStreamerRequestStreamArgsTypeArgs{}
}

func (o *MyStreamerRequestStreamArgsTypeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			err = o.Value.Decode(decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsTypeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	o.Value.Encode(encoder)

	return nil
}

type MyStreamerRequestStreamArgsEnumArgs struct {
	Value MyEnum `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsEnumArgs returns a
// `MyStreamerRequestStreamArgsEnumArgs` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsEnumArgs() MyStreamerRequestStreamArgsEnumArgs {
	return MyStreamerRequestStreamArgsEnumArgs{}
}

func (o *MyStreamerRequestStreamArgsEnumArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Numeric[MyEnum](decoder.ReadInt32())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsEnumArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteInt32(int32(o.Value))

	return nil
}

type MyStreamerRequestStreamArgsUUIDArgs struct {
	Value uuid.UUID `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsUUIDArgs returns a
// `MyStreamerRequestStreamArgsUUIDArgs` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsUUIDArgs() MyStreamerRequestStreamArgsUUIDArgs {
	return MyStreamerRequestStreamArgsUUIDArgs{}
}

func (o *MyStreamerRequestStreamArgsUUIDArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsUUIDArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteString(o.Value.String())

	return nil
}

type MyStreamerRequestStreamArgsAliasArgs struct {
	Value MyAlias `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsAliasArgs returns a
// `MyStreamerRequestStreamArgsAliasArgs` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsAliasArgs() MyStreamerRequestStreamArgsAliasArgs {
	return MyStreamerRequestStreamArgsAliasArgs{}
}

func (o *MyStreamerRequestStreamArgsAliasArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.String[MyAlias](decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsAliasArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteString(string(o.Value))

	return nil
}

type MyStreamerRequestStreamArgsStringArgs struct {
	Value string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsStringArgs returns a
// `MyStreamerRequestStreamArgsStringArgs` struct populated with its default
// values.
func DefaultMyStreamerRequestStreamArgsStringArgs() MyStreamerRequestStreamArgsStringArgs {
	return MyStreamerRequestStreamArgsStringArgs{}
}

func (o *MyStreamerRequestStreamArgsStringArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsStringArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteString(o.Value)

	return nil
}

type MyStreamerRequestStreamArgsBoolArgs struct {
	Value bool `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsBoolArgs returns a
// `MyStreamerRequestStreamArgsBoolArgs` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsBoolArgs() MyStreamerRequestStreamArgsBoolArgs {
	return MyStreamerRequestStreamArgsBoolArgs{}
}

func (o *MyStreamerRequestStreamArgsBoolArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadBool()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsBoolArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteBool(o.Value)

	return nil
}

type MyStreamerRequestStreamArgsDatetimeArgs struct {
	Value time.Time `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsDatetimeArgs returns a
// `MyStreamerRequestStreamArgsDatetimeArgs` struct populated with its default
// values.
func DefaultMyStreamerRequestStreamArgsDatetimeArgs() MyStreamerRequestStreamArgsDatetimeArgs {
	return MyStreamerRequestStreamArgsDatetimeArgs{}
}

func (o *MyStreamerRequestStreamArgsDatetimeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadTime()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsDatetimeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteTime(o.Value)

	return nil
}

type MyStreamerRequestStreamArgsListArgs struct {
	Value []string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsListArgs returns a
// `MyStreamerRequestStreamArgsListArgs` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsListArgs() MyStreamerRequestStreamArgsListArgs {
	return MyStreamerRequestStreamArgsListArgs{}
}

func (o *MyStreamerRequestStreamArgsListArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadSlice(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsListArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteArraySize(uint32(len(o.Value)))
	for _, v := range o.Value {
		encoder.WriteString(v)
	}

	return nil
}

type MyStreamerRequestStreamArgsMapArgs struct {
	Value map[string]string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestStreamArgsMapArgs returns a
// `MyStreamerRequestStreamArgsMapArgs` struct populated with its default values.
func DefaultMyStreamerRequestStreamArgsMapArgs() MyStreamerRequestStreamArgsMapArgs {
	return MyStreamerRequestStreamArgsMapArgs{}
}

func (o *MyStreamerRequestStreamArgsMapArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadMap(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestStreamArgsMapArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteMapSize(uint32(len(o.Value)))
	if o.Value != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.Value {
			encoder.WriteString(k)
			encoder.WriteString(v)
		}
	}

	return nil
}

type MyStreamerRequestChannelArgsSingleArgs struct {
	Value int64 `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsSingleArgs returns a
// `MyStreamerRequestChannelArgsSingleArgs` struct populated with its default
// values.
func DefaultMyStreamerRequestChannelArgsSingleArgs() MyStreamerRequestChannelArgsSingleArgs {
	return MyStreamerRequestChannelArgsSingleArgs{}
}

func (o *MyStreamerRequestChannelArgsSingleArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsSingleArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteInt64(o.Value)

	return nil
}

type MyStreamerRequestChannelArgsI64Args struct {
	Value int64 `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsI64Args returns a
// `MyStreamerRequestChannelArgsI64Args` struct populated with its default values.
func DefaultMyStreamerRequestChannelArgsI64Args() MyStreamerRequestChannelArgsI64Args {
	return MyStreamerRequestChannelArgsI64Args{}
}

func (o *MyStreamerRequestChannelArgsI64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsI64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteInt64(o.Value)

	return nil
}

type MyStreamerRequestChannelArgsF64Args struct {
	Value float64 `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsF64Args returns a
// `MyStreamerRequestChannelArgsF64Args` struct populated with its default values.
func DefaultMyStreamerRequestChannelArgsF64Args() MyStreamerRequestChannelArgsF64Args {
	return MyStreamerRequestChannelArgsF64Args{}
}

func (o *MyStreamerRequestChannelArgsF64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadFloat64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsF64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteFloat64(o.Value)

	return nil
}

type MyStreamerRequestChannelArgsTypeArgs struct {
	Value MyType `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsTypeArgs returns a
// `MyStreamerRequestChannelArgsTypeArgs` struct populated with its default values.
func DefaultMyStreamerRequestChannelArgsTypeArgs() MyStreamerRequestChannelArgsTypeArgs {
	return MyStreamerRequestChannelArgsTypeArgs{}
}

func (o *MyStreamerRequestChannelArgsTypeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			err = o.Value.Decode(decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsTypeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	o.Value.Encode(encoder)

	return nil
}

type MyStreamerRequestChannelArgsEnumArgs struct {
	Value MyEnum `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsEnumArgs returns a
// `MyStreamerRequestChannelArgsEnumArgs` struct populated with its default values.
func DefaultMyStreamerRequestChannelArgsEnumArgs() MyStreamerRequestChannelArgsEnumArgs {
	return MyStreamerRequestChannelArgsEnumArgs{}
}

func (o *MyStreamerRequestChannelArgsEnumArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Numeric[MyEnum](decoder.ReadInt32())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsEnumArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteInt32(int32(o.Value))

	return nil
}

type MyStreamerRequestChannelArgsAliasArgs struct {
	Value uuid.UUID `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsAliasArgs returns a
// `MyStreamerRequestChannelArgsAliasArgs` struct populated with its default
// values.
func DefaultMyStreamerRequestChannelArgsAliasArgs() MyStreamerRequestChannelArgsAliasArgs {
	return MyStreamerRequestChannelArgsAliasArgs{}
}

func (o *MyStreamerRequestChannelArgsAliasArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsAliasArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteString(o.Value.String())

	return nil
}

type MyStreamerRequestChannelArgsStringArgs struct {
	Value string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsStringArgs returns a
// `MyStreamerRequestChannelArgsStringArgs` struct populated with its default
// values.
func DefaultMyStreamerRequestChannelArgsStringArgs() MyStreamerRequestChannelArgsStringArgs {
	return MyStreamerRequestChannelArgsStringArgs{}
}

func (o *MyStreamerRequestChannelArgsStringArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsStringArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteString(o.Value)

	return nil
}

type MyStreamerRequestChannelArgsBoolArgs struct {
	Value bool `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsBoolArgs returns a
// `MyStreamerRequestChannelArgsBoolArgs` struct populated with its default values.
func DefaultMyStreamerRequestChannelArgsBoolArgs() MyStreamerRequestChannelArgsBoolArgs {
	return MyStreamerRequestChannelArgsBoolArgs{}
}

func (o *MyStreamerRequestChannelArgsBoolArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadBool()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsBoolArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteBool(o.Value)

	return nil
}

type MyStreamerRequestChannelArgsDatetimeArgs struct {
	Value time.Time `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsDatetimeArgs returns a
// `MyStreamerRequestChannelArgsDatetimeArgs` struct populated with its default
// values.
func DefaultMyStreamerRequestChannelArgsDatetimeArgs() MyStreamerRequestChannelArgsDatetimeArgs {
	return MyStreamerRequestChannelArgsDatetimeArgs{}
}

func (o *MyStreamerRequestChannelArgsDatetimeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadTime()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsDatetimeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteTime(o.Value)

	return nil
}

type MyStreamerRequestChannelArgsListArgs struct {
	Value []string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsListArgs returns a
// `MyStreamerRequestChannelArgsListArgs` struct populated with its default values.
func DefaultMyStreamerRequestChannelArgsListArgs() MyStreamerRequestChannelArgsListArgs {
	return MyStreamerRequestChannelArgsListArgs{}
}

func (o *MyStreamerRequestChannelArgsListArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadSlice(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsListArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteArraySize(uint32(len(o.Value)))
	for _, v := range o.Value {
		encoder.WriteString(v)
	}

	return nil
}

type MyStreamerRequestChannelArgsMapArgs struct {
	Value map[string]string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultMyStreamerRequestChannelArgsMapArgs returns a
// `MyStreamerRequestChannelArgsMapArgs` struct populated with its default values.
func DefaultMyStreamerRequestChannelArgsMapArgs() MyStreamerRequestChannelArgsMapArgs {
	return MyStreamerRequestChannelArgsMapArgs{}
}

func (o *MyStreamerRequestChannelArgsMapArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadMap(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyStreamerRequestChannelArgsMapArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteMapSize(uint32(len(o.Value)))
	if o.Value != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.Value {
			encoder.WriteString(k)
			encoder.WriteString(v)
		}
	}

	return nil
}

type MyServiceFuncTypeArgs struct {
	Value    MyType  `json:"value" yaml:"value" msgpack:"value"`
	Optional *MyType `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncTypeArgs returns a `MyServiceFuncTypeArgs` struct populated
// with its default values.
func DefaultMyServiceFuncTypeArgs() MyServiceFuncTypeArgs {
	return MyServiceFuncTypeArgs{}
}

func (o *MyServiceFuncTypeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			err = o.Value.Decode(decoder)
		case "optional":
			o.Optional, err = msgpack.DecodeNillable[MyType](decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncTypeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	o.Value.Encode(encoder)
	encoder.WriteString("optional")
	o.Optional.Encode(encoder)

	return nil
}

type MyServiceFuncEnumArgs struct {
	Value    MyEnum  `json:"value" yaml:"value" msgpack:"value"`
	Optional *MyEnum `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncEnumArgs returns a `MyServiceFuncEnumArgs` struct populated
// with its default values.
func DefaultMyServiceFuncEnumArgs() MyServiceFuncEnumArgs {
	return MyServiceFuncEnumArgs{}
}

func (o *MyServiceFuncEnumArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Numeric[MyEnum](decoder.ReadInt32())
		case "optional":
			o.Optional, err = convert.NillableNumeric[MyEnum](decoder.ReadNillableInt32())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncEnumArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteInt32(int32(o.Value))
	encoder.WriteString("optional")
	encoder.WriteNillableInt32((*int32)(o.Optional))

	return nil
}

type MyServiceFuncUUIDArgs struct {
	Value    uuid.UUID  `json:"value" yaml:"value" msgpack:"value"`
	Optional *uuid.UUID `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncUUIDArgs returns a `MyServiceFuncUUIDArgs` struct populated
// with its default values.
func DefaultMyServiceFuncUUIDArgs() MyServiceFuncUUIDArgs {
	return MyServiceFuncUUIDArgs{}
}

func (o *MyServiceFuncUUIDArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "optional":
			o.Optional, err = convert.NillableParse(uuid.Parse)(decoder.ReadNillableString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncUUIDArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteString(o.Value.String())
	encoder.WriteString("optional")
	if o.Optional == nil {
		encoder.WriteNil()
	} else {
		encoder.WriteString(o.Optional.String())
	}

	return nil
}

type MyServiceFuncAliasArgs struct {
	Value    MyAlias  `json:"value" yaml:"value" msgpack:"value"`
	Optional *MyAlias `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncAliasArgs returns a `MyServiceFuncAliasArgs` struct
// populated with its default values.
func DefaultMyServiceFuncAliasArgs() MyServiceFuncAliasArgs {
	return MyServiceFuncAliasArgs{}
}

func (o *MyServiceFuncAliasArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.String[MyAlias](decoder.ReadString())
		case "optional":
			o.Optional, err = convert.NillableString[MyAlias](decoder.ReadNillableString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncAliasArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteString(string(o.Value))
	encoder.WriteString("optional")
	encoder.WriteNillableString((*string)(o.Optional))

	return nil
}

type MyServiceFuncStringArgs struct {
	Value    string  `json:"value" yaml:"value" msgpack:"value"`
	Optional *string `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncStringArgs returns a `MyServiceFuncStringArgs` struct
// populated with its default values.
func DefaultMyServiceFuncStringArgs() MyServiceFuncStringArgs {
	return MyServiceFuncStringArgs{}
}

func (o *MyServiceFuncStringArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadString()
		case "optional":
			o.Optional, err = decoder.ReadNillableString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncStringArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteString(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableString(o.Optional)

	return nil
}

type MyServiceFuncI64Args struct {
	Value    int64  `json:"value" yaml:"value" msgpack:"value"`
	Optional *int64 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncI64Args returns a `MyServiceFuncI64Args` struct populated
// with its default values.
func DefaultMyServiceFuncI64Args() MyServiceFuncI64Args {
	return MyServiceFuncI64Args{}
}

func (o *MyServiceFuncI64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt64()
		case "optional":
			o.Optional, err = decoder.ReadNillableInt64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncI64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteInt64(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableInt64(o.Optional)

	return nil
}

type MyServiceFuncI32Args struct {
	Value    int32  `json:"value" yaml:"value" msgpack:"value"`
	Optional *int32 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncI32Args returns a `MyServiceFuncI32Args` struct populated
// with its default values.
func DefaultMyServiceFuncI32Args() MyServiceFuncI32Args {
	return MyServiceFuncI32Args{}
}

func (o *MyServiceFuncI32Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt32()
		case "optional":
			o.Optional, err = decoder.ReadNillableInt32()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncI32Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteInt32(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableInt32(o.Optional)

	return nil
}

type MyServiceFuncI16Args struct {
	Value    int16  `json:"value" yaml:"value" msgpack:"value"`
	Optional *int16 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncI16Args returns a `MyServiceFuncI16Args` struct populated
// with its default values.
func DefaultMyServiceFuncI16Args() MyServiceFuncI16Args {
	return MyServiceFuncI16Args{}
}

func (o *MyServiceFuncI16Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt16()
		case "optional":
			o.Optional, err = decoder.ReadNillableInt16()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncI16Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteInt16(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableInt16(o.Optional)

	return nil
}

type MyServiceFuncI8Args struct {
	Value    int8  `json:"value" yaml:"value" msgpack:"value"`
	Optional *int8 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncI8Args returns a `MyServiceFuncI8Args` struct populated with
// its default values.
func DefaultMyServiceFuncI8Args() MyServiceFuncI8Args {
	return MyServiceFuncI8Args{}
}

func (o *MyServiceFuncI8Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt8()
		case "optional":
			o.Optional, err = decoder.ReadNillableInt8()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncI8Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteInt8(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableInt8(o.Optional)

	return nil
}

type MyServiceFuncU64Args struct {
	Value    uint64  `json:"value" yaml:"value" msgpack:"value"`
	Optional *uint64 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncU64Args returns a `MyServiceFuncU64Args` struct populated
// with its default values.
func DefaultMyServiceFuncU64Args() MyServiceFuncU64Args {
	return MyServiceFuncU64Args{}
}

func (o *MyServiceFuncU64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadUint64()
		case "optional":
			o.Optional, err = decoder.ReadNillableUint64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncU64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteUint64(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableUint64(o.Optional)

	return nil
}

type MyServiceFuncU32Args struct {
	Value    uint32  `json:"value" yaml:"value" msgpack:"value"`
	Optional *uint32 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncU32Args returns a `MyServiceFuncU32Args` struct populated
// with its default values.
func DefaultMyServiceFuncU32Args() MyServiceFuncU32Args {
	return MyServiceFuncU32Args{}
}

func (o *MyServiceFuncU32Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadUint32()
		case "optional":
			o.Optional, err = decoder.ReadNillableUint32()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncU32Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteUint32(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableUint32(o.Optional)

	return nil
}

type MyServiceFuncU16Args struct {
	Value    uint16  `json:"value" yaml:"value" msgpack:"value"`
	Optional *uint16 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncU16Args returns a `MyServiceFuncU16Args` struct populated
// with its default values.
func DefaultMyServiceFuncU16Args() MyServiceFuncU16Args {
	return MyServiceFuncU16Args{}
}

func (o *MyServiceFuncU16Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadUint16()
		case "optional":
			o.Optional, err = decoder.ReadNillableUint16()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncU16Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteUint16(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableUint16(o.Optional)

	return nil
}

type MyServiceFuncU8Args struct {
	Value    uint8  `json:"value" yaml:"value" msgpack:"value"`
	Optional *uint8 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncU8Args returns a `MyServiceFuncU8Args` struct populated with
// its default values.
func DefaultMyServiceFuncU8Args() MyServiceFuncU8Args {
	return MyServiceFuncU8Args{}
}

func (o *MyServiceFuncU8Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadUint8()
		case "optional":
			o.Optional, err = decoder.ReadNillableUint8()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncU8Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteUint8(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableUint8(o.Optional)

	return nil
}

type MyServiceFuncF64Args struct {
	Value    float64  `json:"value" yaml:"value" msgpack:"value"`
	Optional *float64 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncF64Args returns a `MyServiceFuncF64Args` struct populated
// with its default values.
func DefaultMyServiceFuncF64Args() MyServiceFuncF64Args {
	return MyServiceFuncF64Args{}
}

func (o *MyServiceFuncF64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadFloat64()
		case "optional":
			o.Optional, err = decoder.ReadNillableFloat64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncF64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteFloat64(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableFloat64(o.Optional)

	return nil
}

type MyServiceFuncF32Args struct {
	Value    float32  `json:"value" yaml:"value" msgpack:"value"`
	Optional *float32 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncF32Args returns a `MyServiceFuncF32Args` struct populated
// with its default values.
func DefaultMyServiceFuncF32Args() MyServiceFuncF32Args {
	return MyServiceFuncF32Args{}
}

func (o *MyServiceFuncF32Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadFloat32()
		case "optional":
			o.Optional, err = decoder.ReadNillableFloat32()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncF32Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteFloat32(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableFloat32(o.Optional)

	return nil
}

type MyServiceFuncBytesArgs struct {
	Value    []byte `json:"value" yaml:"value" msgpack:"value"`
	Optional []byte `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncBytesArgs returns a `MyServiceFuncBytesArgs` struct
// populated with its default values.
func DefaultMyServiceFuncBytesArgs() MyServiceFuncBytesArgs {
	return MyServiceFuncBytesArgs{}
}

func (o *MyServiceFuncBytesArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadByteArray()
		case "optional":
			o.Optional, err = decoder.ReadNillableByteArray()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncBytesArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteByteArray(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableByteArray(o.Optional)

	return nil
}

type MyServiceFuncDatetimeArgs struct {
	Value    time.Time  `json:"value" yaml:"value" msgpack:"value"`
	Optional *time.Time `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncDatetimeArgs returns a `MyServiceFuncDatetimeArgs` struct
// populated with its default values.
func DefaultMyServiceFuncDatetimeArgs() MyServiceFuncDatetimeArgs {
	return MyServiceFuncDatetimeArgs{}
}

func (o *MyServiceFuncDatetimeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadTime()
		case "optional":
			o.Optional, err = decoder.ReadNillableTime()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncDatetimeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteTime(o.Value)
	encoder.WriteString("optional")
	encoder.WriteNillableTime(o.Optional)

	return nil
}

type MyServiceFuncListArgs struct {
	Value    []string `json:"value" yaml:"value" msgpack:"value"`
	Optional []string `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncListArgs returns a `MyServiceFuncListArgs` struct populated
// with its default values.
func DefaultMyServiceFuncListArgs() MyServiceFuncListArgs {
	return MyServiceFuncListArgs{}
}

func (o *MyServiceFuncListArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadSlice(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		case "optional":
			o.Optional, err = msgpack.ReadSlice(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncListArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteArraySize(uint32(len(o.Value)))
	for _, v := range o.Value {
		encoder.WriteString(v)
	}
	encoder.WriteString("optional")
	encoder.WriteArraySize(uint32(len(o.Optional)))
	for _, v := range o.Optional {
		encoder.WriteString(v)
	}

	return nil
}

type MyServiceFuncMapArgs struct {
	Value    map[string]string `json:"value" yaml:"value" msgpack:"value"`
	Optional map[string]string `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
}

// DefaultMyServiceFuncMapArgs returns a `MyServiceFuncMapArgs` struct populated
// with its default values.
func DefaultMyServiceFuncMapArgs() MyServiceFuncMapArgs {
	return MyServiceFuncMapArgs{}
}

func (o *MyServiceFuncMapArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadMap(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		case "optional":
			o.Optional, err = msgpack.ReadMap(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyServiceFuncMapArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("value")
	encoder.WriteMapSize(uint32(len(o.Value)))
	if o.Value != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.Value {
			encoder.WriteString(k)
			encoder.WriteString(v)
		}
	}
	encoder.WriteString("optional")
	encoder.WriteMapSize(uint32(len(o.Optional)))
	if o.Optional != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.Optional {
			encoder.WriteString(k)
			encoder.WriteString(v)
		}
	}

	return nil
}

type RepositoryRequestStreamArgsI64Args struct {
	Value int64 `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestStreamArgsI64Args returns a
// `RepositoryRequestStreamArgsI64Args` struct populated with its default values.
func DefaultRepositoryRequestStreamArgsI64Args() RepositoryRequestStreamArgsI64Args {
	return RepositoryRequestStreamArgsI64Args{}
}

func (o *RepositoryRequestStreamArgsI64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestStreamArgsI64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteInt64(o.Value)

	return nil
}

type RepositoryRequestStreamArgsF64Args struct {
	Value float64 `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestStreamArgsF64Args returns a
// `RepositoryRequestStreamArgsF64Args` struct populated with its default values.
func DefaultRepositoryRequestStreamArgsF64Args() RepositoryRequestStreamArgsF64Args {
	return RepositoryRequestStreamArgsF64Args{}
}

func (o *RepositoryRequestStreamArgsF64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadFloat64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestStreamArgsF64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteFloat64(o.Value)

	return nil
}

type RepositoryRequestStreamArgsTypeArgs struct {
	Value MyType `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestStreamArgsTypeArgs returns a
// `RepositoryRequestStreamArgsTypeArgs` struct populated with its default values.
func DefaultRepositoryRequestStreamArgsTypeArgs() RepositoryRequestStreamArgsTypeArgs {
	return RepositoryRequestStreamArgsTypeArgs{}
}

func (o *RepositoryRequestStreamArgsTypeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			err = o.Value.Decode(decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestStreamArgsTypeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	o.Value.Encode(encoder)

	return nil
}

type RepositoryRequestStreamArgsEnumArgs struct {
	Value MyEnum `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestStreamArgsEnumArgs returns a
// `RepositoryRequestStreamArgsEnumArgs` struct populated with its default values.
func DefaultRepositoryRequestStreamArgsEnumArgs() RepositoryRequestStreamArgsEnumArgs {
	return RepositoryRequestStreamArgsEnumArgs{}
}

func (o *RepositoryRequestStreamArgsEnumArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Numeric[MyEnum](decoder.ReadInt32())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestStreamArgsEnumArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteInt32(int32(o.Value))

	return nil
}

type RepositoryRequestStreamArgsUUIDArgs struct {
	Value uuid.UUID `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestStreamArgsUUIDArgs returns a
// `RepositoryRequestStreamArgsUUIDArgs` struct populated with its default values.
func DefaultRepositoryRequestStreamArgsUUIDArgs() RepositoryRequestStreamArgsUUIDArgs {
	return RepositoryRequestStreamArgsUUIDArgs{}
}

func (o *RepositoryRequestStreamArgsUUIDArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestStreamArgsUUIDArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteString(o.Value.String())

	return nil
}

type RepositoryRequestStreamArgsAliasArgs struct {
	Value MyAlias `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestStreamArgsAliasArgs returns a
// `RepositoryRequestStreamArgsAliasArgs` struct populated with its default values.
func DefaultRepositoryRequestStreamArgsAliasArgs() RepositoryRequestStreamArgsAliasArgs {
	return RepositoryRequestStreamArgsAliasArgs{}
}

func (o *RepositoryRequestStreamArgsAliasArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.String[MyAlias](decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestStreamArgsAliasArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteString(string(o.Value))

	return nil
}

type RepositoryRequestStreamArgsStringArgs struct {
	Value string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestStreamArgsStringArgs returns a
// `RepositoryRequestStreamArgsStringArgs` struct populated with its default
// values.
func DefaultRepositoryRequestStreamArgsStringArgs() RepositoryRequestStreamArgsStringArgs {
	return RepositoryRequestStreamArgsStringArgs{}
}

func (o *RepositoryRequestStreamArgsStringArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestStreamArgsStringArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteString(o.Value)

	return nil
}

type RepositoryRequestStreamArgsBoolArgs struct {
	Value bool `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestStreamArgsBoolArgs returns a
// `RepositoryRequestStreamArgsBoolArgs` struct populated with its default values.
func DefaultRepositoryRequestStreamArgsBoolArgs() RepositoryRequestStreamArgsBoolArgs {
	return RepositoryRequestStreamArgsBoolArgs{}
}

func (o *RepositoryRequestStreamArgsBoolArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadBool()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestStreamArgsBoolArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteBool(o.Value)

	return nil
}

type RepositoryRequestStreamArgsDatetimeArgs struct {
	Value time.Time `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestStreamArgsDatetimeArgs returns a
// `RepositoryRequestStreamArgsDatetimeArgs` struct populated with its default
// values.
func DefaultRepositoryRequestStreamArgsDatetimeArgs() RepositoryRequestStreamArgsDatetimeArgs {
	return RepositoryRequestStreamArgsDatetimeArgs{}
}

func (o *RepositoryRequestStreamArgsDatetimeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadTime()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestStreamArgsDatetimeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteTime(o.Value)

	return nil
}

type RepositoryRequestStreamArgsListArgs struct {
	Value []string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestStreamArgsListArgs returns a
// `RepositoryRequestStreamArgsListArgs` struct populated with its default values.
func DefaultRepositoryRequestStreamArgsListArgs() RepositoryRequestStreamArgsListArgs {
	return RepositoryRequestStreamArgsListArgs{}
}

func (o *RepositoryRequestStreamArgsListArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadSlice(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestStreamArgsListArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteArraySize(uint32(len(o.Value)))
	for _, v := range o.Value {
		encoder.WriteString(v)
	}

	return nil
}

type RepositoryRequestStreamArgsMapArgs struct {
	Value map[string]string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestStreamArgsMapArgs returns a
// `RepositoryRequestStreamArgsMapArgs` struct populated with its default values.
func DefaultRepositoryRequestStreamArgsMapArgs() RepositoryRequestStreamArgsMapArgs {
	return RepositoryRequestStreamArgsMapArgs{}
}

func (o *RepositoryRequestStreamArgsMapArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadMap(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestStreamArgsMapArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteMapSize(uint32(len(o.Value)))
	if o.Value != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.Value {
			encoder.WriteString(k)
			encoder.WriteString(v)
		}
	}

	return nil
}

type RepositoryRequestChannelArgsI64Args struct {
	Value int64 `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestChannelArgsI64Args returns a
// `RepositoryRequestChannelArgsI64Args` struct populated with its default values.
func DefaultRepositoryRequestChannelArgsI64Args() RepositoryRequestChannelArgsI64Args {
	return RepositoryRequestChannelArgsI64Args{}
}

func (o *RepositoryRequestChannelArgsI64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadInt64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestChannelArgsI64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteInt64(o.Value)

	return nil
}

type RepositoryRequestChannelArgsF64Args struct {
	Value float64 `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestChannelArgsF64Args returns a
// `RepositoryRequestChannelArgsF64Args` struct populated with its default values.
func DefaultRepositoryRequestChannelArgsF64Args() RepositoryRequestChannelArgsF64Args {
	return RepositoryRequestChannelArgsF64Args{}
}

func (o *RepositoryRequestChannelArgsF64Args) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadFloat64()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestChannelArgsF64Args) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteFloat64(o.Value)

	return nil
}

type RepositoryRequestChannelArgsTypeArgs struct {
	Value MyType `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestChannelArgsTypeArgs returns a
// `RepositoryRequestChannelArgsTypeArgs` struct populated with its default values.
func DefaultRepositoryRequestChannelArgsTypeArgs() RepositoryRequestChannelArgsTypeArgs {
	return RepositoryRequestChannelArgsTypeArgs{}
}

func (o *RepositoryRequestChannelArgsTypeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			err = o.Value.Decode(decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestChannelArgsTypeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	o.Value.Encode(encoder)

	return nil
}

type RepositoryRequestChannelArgsEnumArgs struct {
	Value MyEnum `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestChannelArgsEnumArgs returns a
// `RepositoryRequestChannelArgsEnumArgs` struct populated with its default values.
func DefaultRepositoryRequestChannelArgsEnumArgs() RepositoryRequestChannelArgsEnumArgs {
	return RepositoryRequestChannelArgsEnumArgs{}
}

func (o *RepositoryRequestChannelArgsEnumArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Numeric[MyEnum](decoder.ReadInt32())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestChannelArgsEnumArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteInt32(int32(o.Value))

	return nil
}

type RepositoryRequestChannelArgsAliasArgs struct {
	Value uuid.UUID `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestChannelArgsAliasArgs returns a
// `RepositoryRequestChannelArgsAliasArgs` struct populated with its default
// values.
func DefaultRepositoryRequestChannelArgsAliasArgs() RepositoryRequestChannelArgsAliasArgs {
	return RepositoryRequestChannelArgsAliasArgs{}
}

func (o *RepositoryRequestChannelArgsAliasArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestChannelArgsAliasArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteString(o.Value.String())

	return nil
}

type RepositoryRequestChannelArgsStringArgs struct {
	Value string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestChannelArgsStringArgs returns a
// `RepositoryRequestChannelArgsStringArgs` struct populated with its default
// values.
func DefaultRepositoryRequestChannelArgsStringArgs() RepositoryRequestChannelArgsStringArgs {
	return RepositoryRequestChannelArgsStringArgs{}
}

func (o *RepositoryRequestChannelArgsStringArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestChannelArgsStringArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteString(o.Value)

	return nil
}

type RepositoryRequestChannelArgsBoolArgs struct {
	Value bool `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestChannelArgsBoolArgs returns a
// `RepositoryRequestChannelArgsBoolArgs` struct populated with its default values.
func DefaultRepositoryRequestChannelArgsBoolArgs() RepositoryRequestChannelArgsBoolArgs {
	return RepositoryRequestChannelArgsBoolArgs{}
}

func (o *RepositoryRequestChannelArgsBoolArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadBool()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestChannelArgsBoolArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteBool(o.Value)

	return nil
}

type RepositoryRequestChannelArgsDatetimeArgs struct {
	Value time.Time `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestChannelArgsDatetimeArgs returns a
// `RepositoryRequestChannelArgsDatetimeArgs` struct populated with its default
// values.
func DefaultRepositoryRequestChannelArgsDatetimeArgs() RepositoryRequestChannelArgsDatetimeArgs {
	return RepositoryRequestChannelArgsDatetimeArgs{}
}

func (o *RepositoryRequestChannelArgsDatetimeArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = decoder.ReadTime()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestChannelArgsDatetimeArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteTime(o.Value)

	return nil
}

type RepositoryRequestChannelArgsListArgs struct {
	Value []string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestChannelArgsListArgs returns a
// `RepositoryRequestChannelArgsListArgs` struct populated with its default values.
func DefaultRepositoryRequestChannelArgsListArgs() RepositoryRequestChannelArgsListArgs {
	return RepositoryRequestChannelArgsListArgs{}
}

func (o *RepositoryRequestChannelArgsListArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadSlice(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestChannelArgsListArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteArraySize(uint32(len(o.Value)))
	for _, v := range o.Value {
		encoder.WriteString(v)
	}

	return nil
}

type RepositoryRequestChannelArgsMapArgs struct {
	Value map[string]string `json:"value" yaml:"value" msgpack:"value"`
}

// DefaultRepositoryRequestChannelArgsMapArgs returns a
// `RepositoryRequestChannelArgsMapArgs` struct populated with its default values.
func DefaultRepositoryRequestChannelArgsMapArgs() RepositoryRequestChannelArgsMapArgs {
	return RepositoryRequestChannelArgsMapArgs{}
}

func (o *RepositoryRequestChannelArgsMapArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "value":
			o.Value, err = msgpack.ReadMap(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *RepositoryRequestChannelArgsMapArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("value")
	encoder.WriteMapSize(uint32(len(o.Value)))
	if o.Value != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.Value {
			encoder.WriteString(k)
			encoder.WriteString(v)
		}
	}

	return nil
}

func (o *MyType) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "sameValue":
			o.SameValue, err = msgpack.DecodeNillable[MyType](decoder)
		case "typeValue":
			err = o.TypeValue.Decode(decoder)
		case "stringValue":
			o.StringValue, err = decoder.ReadString()
		case "stringOption":
			o.StringOption, err = decoder.ReadNillableString()
		case "i64Value":
			o.I64Value, err = decoder.ReadInt64()
		case "i64Option":
			o.I64Option, err = decoder.ReadNillableInt64()
		case "i32Value":
			o.I32Value, err = decoder.ReadInt32()
		case "i32Option":
			o.I32Option, err = decoder.ReadNillableInt32()
		case "i16Value":
			o.I16Value, err = decoder.ReadInt16()
		case "i16Option":
			o.I16Option, err = decoder.ReadNillableInt16()
		case "i8Value":
			o.I8Value, err = decoder.ReadInt8()
		case "i8Option":
			o.I8Option, err = decoder.ReadNillableInt8()
		case "u64Value":
			o.U64Value, err = decoder.ReadUint64()
		case "u64Option":
			o.U64Option, err = decoder.ReadNillableUint64()
		case "u32Value":
			o.U32Value, err = decoder.ReadUint32()
		case "u32Option":
			o.U32Option, err = decoder.ReadNillableUint32()
		case "u16Value":
			o.U16Value, err = decoder.ReadUint16()
		case "u16Option":
			o.U16Option, err = decoder.ReadNillableUint16()
		case "u8Value":
			o.U8Value, err = decoder.ReadUint8()
		case "u8Option":
			o.U8Option, err = decoder.ReadNillableUint8()
		case "f64Value":
			o.F64Value, err = decoder.ReadFloat64()
		case "f64Option":
			o.F64Option, err = decoder.ReadNillableFloat64()
		case "f32Value":
			o.F32Value, err = decoder.ReadFloat32()
		case "f32Option":
			o.F32Option, err = decoder.ReadNillableFloat32()
		case "datetimeValue":
			o.DatetimeValue, err = decoder.ReadTime()
		case "datetimeOption":
			o.DatetimeOption, err = decoder.ReadNillableTime()
		case "bytesValue":
			o.BytesValue, err = decoder.ReadByteArray()
		case "bytesOption":
			o.BytesOption, err = decoder.ReadNillableByteArray()
		case "mapValue":
			o.MapValue, err = msgpack.ReadMap(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (int64, error) {
				return decoder.ReadInt64()
			})
		case "mapOfTypes":
			o.MapOfTypes, err = msgpack.ReadMap(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (MyType, error) {
				return msgpack.Decode[MyType](decoder)
			})
		case "arrayValue":
			o.ArrayValue, err = msgpack.ReadSlice(decoder, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})
		case "arrayOfTypes":
			o.ArrayOfTypes, err = msgpack.ReadSlice(decoder, func(decoder msgpack.Reader) (MyType, error) {
				return msgpack.Decode[MyType](decoder)
			})
		case "unionValue":
			o.UnionValue, err = msgpack.Decode[MyUnion](decoder)
		case "unionOption":
			o.UnionOption, err = msgpack.DecodeNillable[MyUnion](decoder)
		case "enumValue":
			o.EnumValue, err = convert.Numeric[MyEnum](decoder.ReadInt32())
		case "enumOption":
			o.EnumOption, err = convert.NillableNumeric[MyEnum](decoder.ReadNillableInt32())
		case "aliasValue":
			o.AliasValue, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "aliasOption":
			o.AliasOption, err = convert.NillableParse(uuid.Parse)(decoder.ReadNillableString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyType) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(38)
	encoder.WriteString("sameValue")
	o.SameValue.Encode(encoder)
	encoder.WriteString("typeValue")
	o.TypeValue.Encode(encoder)
	encoder.WriteString("stringValue")
	encoder.WriteString(o.StringValue)
	encoder.WriteString("stringOption")
	encoder.WriteNillableString(o.StringOption)
	encoder.WriteString("i64Value")
	encoder.WriteInt64(o.I64Value)
	encoder.WriteString("i64Option")
	encoder.WriteNillableInt64(o.I64Option)
	encoder.WriteString("i32Value")
	encoder.WriteInt32(o.I32Value)
	encoder.WriteString("i32Option")
	encoder.WriteNillableInt32(o.I32Option)
	encoder.WriteString("i16Value")
	encoder.WriteInt16(o.I16Value)
	encoder.WriteString("i16Option")
	encoder.WriteNillableInt16(o.I16Option)
	encoder.WriteString("i8Value")
	encoder.WriteInt8(o.I8Value)
	encoder.WriteString("i8Option")
	encoder.WriteNillableInt8(o.I8Option)
	encoder.WriteString("u64Value")
	encoder.WriteUint64(o.U64Value)
	encoder.WriteString("u64Option")
	encoder.WriteNillableUint64(o.U64Option)
	encoder.WriteString("u32Value")
	encoder.WriteUint32(o.U32Value)
	encoder.WriteString("u32Option")
	encoder.WriteNillableUint32(o.U32Option)
	encoder.WriteString("u16Value")
	encoder.WriteUint16(o.U16Value)
	encoder.WriteString("u16Option")
	encoder.WriteNillableUint16(o.U16Option)
	encoder.WriteString("u8Value")
	encoder.WriteUint8(o.U8Value)
	encoder.WriteString("u8Option")
	encoder.WriteNillableUint8(o.U8Option)
	encoder.WriteString("f64Value")
	encoder.WriteFloat64(o.F64Value)
	encoder.WriteString("f64Option")
	encoder.WriteNillableFloat64(o.F64Option)
	encoder.WriteString("f32Value")
	encoder.WriteFloat32(o.F32Value)
	encoder.WriteString("f32Option")
	encoder.WriteNillableFloat32(o.F32Option)
	encoder.WriteString("datetimeValue")
	encoder.WriteTime(o.DatetimeValue)
	encoder.WriteString("datetimeOption")
	encoder.WriteNillableTime(o.DatetimeOption)
	encoder.WriteString("bytesValue")
	encoder.WriteByteArray(o.BytesValue)
	encoder.WriteString("bytesOption")
	encoder.WriteNillableByteArray(o.BytesOption)
	encoder.WriteString("mapValue")
	encoder.WriteMapSize(uint32(len(o.MapValue)))
	if o.MapValue != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.MapValue {
			encoder.WriteString(k)
			encoder.WriteInt64(v)
		}
	}
	encoder.WriteString("mapOfTypes")
	encoder.WriteMapSize(uint32(len(o.MapOfTypes)))
	if o.MapOfTypes != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.MapOfTypes {
			encoder.WriteString(k)
			v.Encode(encoder)
		}
	}
	encoder.WriteString("arrayValue")
	encoder.WriteArraySize(uint32(len(o.ArrayValue)))
	for _, v := range o.ArrayValue {
		encoder.WriteString(v)
	}
	encoder.WriteString("arrayOfTypes")
	encoder.WriteArraySize(uint32(len(o.ArrayOfTypes)))
	for _, v := range o.ArrayOfTypes {
		v.Encode(encoder)
	}
	encoder.WriteString("unionValue")
	o.UnionValue.Encode(encoder)
	encoder.WriteString("unionOption")
	if o.UnionOption == nil {
		encoder.WriteNil()
	} else {
		o.UnionOption.Encode(encoder)
	}
	encoder.WriteString("enumValue")
	encoder.WriteInt32(int32(o.EnumValue))
	encoder.WriteString("enumOption")
	encoder.WriteNillableInt32((*int32)(o.EnumOption))
	encoder.WriteString("aliasValue")
	encoder.WriteString(o.AliasValue.String())
	encoder.WriteString("aliasOption")
	if o.AliasOption == nil {
		encoder.WriteNil()
	} else {
		encoder.WriteString(o.AliasOption.String())
	}

	return nil
}

func (o *MyOtherType) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "foo":
			o.Foo, err = decoder.ReadString()
		case "bar":
			o.Bar, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyOtherType) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("foo")
	encoder.WriteString(o.Foo)
	encoder.WriteString("bar")
	encoder.WriteString(o.Bar)

	return nil
}

func (o *MyUnion) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "MyType":
			o.MyType, err = msgpack.DecodeNillable[MyType](decoder)
		case "MyEnum":
			o.MyEnum, err = convert.NillableNumeric[MyEnum](decoder.ReadNillableInt32())
		case "string":
			o.String, err = decoder.ReadNillableString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyUnion) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	if o.MyType != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("MyType")
		o.MyType.Encode(encoder)
		return nil
	}
	if o.MyEnum != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("MyEnum")
		encoder.WriteNillableInt32((*int32)(o.MyEnum))
		return nil
	}
	if o.String != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("string")
		encoder.WriteNillableString(o.String)
		return nil
	}

	encoder.WriteNil()
	return nil
}

func RegisterMyStreamer(svc MyStreamer) {
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamI64", myStreamerRequestStreamI64Wrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamF64", myStreamerRequestStreamF64Wrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamType", myStreamerRequestStreamTypeWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamEnum", myStreamerRequestStreamEnumWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamUUID", myStreamerRequestStreamUUIDWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamAlias", myStreamerRequestStreamAliasWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamString", myStreamerRequestStreamStringWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamBool", myStreamerRequestStreamBoolWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamDatetime", myStreamerRequestStreamDatetimeWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamList", myStreamerRequestStreamListWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamMap", myStreamerRequestStreamMapWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamArgsI64", myStreamerRequestStreamArgsI64Wrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamArgsF64", myStreamerRequestStreamArgsF64Wrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamArgsType", myStreamerRequestStreamArgsTypeWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamArgsEnum", myStreamerRequestStreamArgsEnumWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamArgsUUID", myStreamerRequestStreamArgsUUIDWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamArgsAlias", myStreamerRequestStreamArgsAliasWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamArgsString", myStreamerRequestStreamArgsStringWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamArgsBool", myStreamerRequestStreamArgsBoolWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamArgsDatetime", myStreamerRequestStreamArgsDatetimeWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamArgsList", myStreamerRequestStreamArgsListWrapper(svc))
	invoke.ExportRequestStream("iota.testing.MyStreamer", "requestStreamArgsMap", myStreamerRequestStreamArgsMapWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelVoid", myStreamerRequestChannelVoidWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelSingle", myStreamerRequestChannelSingleWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelI64", myStreamerRequestChannelI64Wrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelF64", myStreamerRequestChannelF64Wrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelType", myStreamerRequestChannelTypeWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelEnum", myStreamerRequestChannelEnumWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelAlias", myStreamerRequestChannelAliasWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelString", myStreamerRequestChannelStringWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelBool", myStreamerRequestChannelBoolWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelDatetime", myStreamerRequestChannelDatetimeWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelList", myStreamerRequestChannelListWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelMap", myStreamerRequestChannelMapWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsSingle", myStreamerRequestChannelArgsSingleWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsI64", myStreamerRequestChannelArgsI64Wrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsF64", myStreamerRequestChannelArgsF64Wrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsType", myStreamerRequestChannelArgsTypeWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsEnum", myStreamerRequestChannelArgsEnumWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsAlias", myStreamerRequestChannelArgsAliasWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsString", myStreamerRequestChannelArgsStringWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsBool", myStreamerRequestChannelArgsBoolWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsDatetime", myStreamerRequestChannelArgsDatetimeWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsList", myStreamerRequestChannelArgsListWrapper(svc))
	invoke.ExportRequestChannel("iota.testing.MyStreamer", "requestChannelArgsMap", myStreamerRequestChannelArgsMapWrapper(svc))
}

func RegisterMyService(svc MyService) {
	invoke.ExportRequestResponse("iota.testing.MyService", "emptyVoid", myServiceEmptyVoidWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryType", myServiceUnaryTypeWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryEnum", myServiceUnaryEnumWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryUUID", myServiceUnaryUUIDWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryAlias", myServiceUnaryAliasWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryString", myServiceUnaryStringWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryI64", myServiceUnaryI64Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryI32", myServiceUnaryI32Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryI16", myServiceUnaryI16Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryI8", myServiceUnaryI8Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryU64", myServiceUnaryU64Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryU32", myServiceUnaryU32Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryU16", myServiceUnaryU16Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryU8", myServiceUnaryU8Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryF64", myServiceUnaryF64Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryF32", myServiceUnaryF32Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryBytes", myServiceUnaryBytesWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryDatetime", myServiceUnaryDatetimeWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryList", myServiceUnaryListWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "unaryMap", myServiceUnaryMapWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcType", myServiceFuncTypeWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcEnum", myServiceFuncEnumWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcUUID", myServiceFuncUUIDWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcAlias", myServiceFuncAliasWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcString", myServiceFuncStringWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcI64", myServiceFuncI64Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcI32", myServiceFuncI32Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcI16", myServiceFuncI16Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcI8", myServiceFuncI8Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcU64", myServiceFuncU64Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcU32", myServiceFuncU32Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcU16", myServiceFuncU16Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcU8", myServiceFuncU8Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcF64", myServiceFuncF64Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcF32", myServiceFuncF32Wrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcBytes", myServiceFuncBytesWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcDatetime", myServiceFuncDatetimeWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcList", myServiceFuncListWrapper(svc))
	invoke.ExportRequestResponse("iota.testing.MyService", "funcMap", myServiceFuncMapWrapper(svc))
}

func RegisterSomeCalc(handler SomeCalcFn) {
	invoke.ExportRequestResponse("iota.testing", "someCalc", someCalcWrapper(handler))
}

func someCalcWrapper(handler SomeCalcFn) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultSomeCalcArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := handler(ctx, inputArgs.Rhs, inputArgs.Lhs)
		return mono.Map(response, transform.Int64.Encode)
	}
}

func myStreamerRequestStreamI64Wrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		response := svc.RequestStreamI64(ctx)
		return flux.Map(response, transform.Int64.Encode)
	}
}

func myStreamerRequestStreamF64Wrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		response := svc.RequestStreamF64(ctx)
		return flux.Map(response, transform.Float64.Encode)
	}
}

func myStreamerRequestStreamTypeWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		response := svc.RequestStreamType(ctx)
		return flux.Map(response, transform.MsgPackEncode[MyType])
	}
}

func myStreamerRequestStreamEnumWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		response := svc.RequestStreamEnum(ctx)
		return flux.Map(response, transform.Int32Encode[MyEnum])
	}
}

func myStreamerRequestStreamUUIDWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		response := svc.RequestStreamUUID(ctx)
		return flux.Map(response, transform.ToStringEncode(
			func(v uuid.UUID) string { return v.String() }))
	}
}

func myStreamerRequestStreamAliasWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		response := svc.RequestStreamAlias(ctx)
		return flux.Map(response, transform.StringEncode[MyAlias])
	}
}

func myStreamerRequestStreamStringWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		response := svc.RequestStreamString(ctx)
		return flux.Map(response, transform.String.Encode)
	}
}

func myStreamerRequestStreamBoolWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		response := svc.RequestStreamBool(ctx)
		return flux.Map(response, transform.Bool.Encode)
	}
}

func myStreamerRequestStreamDatetimeWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		response := svc.RequestStreamDatetime(ctx)
		return flux.Map(response, transform.Time.Encode)
	}
}

func myStreamerRequestStreamListWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		response := svc.RequestStreamList(ctx)
		return flux.Map(response, transform.SliceEncode(func(writer msgpack.Writer, val string) {
			writer.WriteString(val)
		}))
	}
}

func myStreamerRequestStreamMapWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		response := svc.RequestStreamMap(ctx)
		return flux.Map(response, transform.MapEncode(func(writer msgpack.Writer, key string) {
			writer.WriteString(key)
		}, func(writer msgpack.Writer, val string) {
			writer.WriteString(val)
		}))
	}
}

func myStreamerRequestStreamArgsI64Wrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestStreamArgsI64Args()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestStreamArgsI64(ctx, inputArgs.Value)
		return flux.Map(response, transform.Int64.Encode)
	}
}

func myStreamerRequestStreamArgsF64Wrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestStreamArgsF64Args()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestStreamArgsF64(ctx, inputArgs.Value)
		return flux.Map(response, transform.Float64.Encode)
	}
}

func myStreamerRequestStreamArgsTypeWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestStreamArgsTypeArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestStreamArgsType(ctx, &inputArgs.Value)
		return flux.Map(response, transform.MsgPackEncode[MyType])
	}
}

func myStreamerRequestStreamArgsEnumWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestStreamArgsEnumArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestStreamArgsEnum(ctx, inputArgs.Value)
		return flux.Map(response, transform.Int32Encode[MyEnum])
	}
}

func myStreamerRequestStreamArgsUUIDWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestStreamArgsUUIDArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestStreamArgsUUID(ctx, inputArgs.Value)
		return flux.Map(response, transform.ToStringEncode(
			func(v uuid.UUID) string { return v.String() }))
	}
}

func myStreamerRequestStreamArgsAliasWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestStreamArgsAliasArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestStreamArgsAlias(ctx, inputArgs.Value)
		return flux.Map(response, transform.StringEncode[MyAlias])
	}
}

func myStreamerRequestStreamArgsStringWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestStreamArgsStringArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestStreamArgsString(ctx, inputArgs.Value)
		return flux.Map(response, transform.String.Encode)
	}
}

func myStreamerRequestStreamArgsBoolWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestStreamArgsBoolArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestStreamArgsBool(ctx, inputArgs.Value)
		return flux.Map(response, transform.Bool.Encode)
	}
}

func myStreamerRequestStreamArgsDatetimeWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestStreamArgsDatetimeArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestStreamArgsDatetime(ctx, inputArgs.Value)
		return flux.Map(response, transform.Time.Encode)
	}
}

func myStreamerRequestStreamArgsListWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestStreamArgsListArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestStreamArgsList(ctx, inputArgs.Value)
		return flux.Map(response, transform.SliceEncode(func(writer msgpack.Writer, val string) {
			writer.WriteString(val)
		}))
	}
}

func myStreamerRequestStreamArgsMapWrapper(svc MyStreamer) invoke.RequestStreamHandler {
	return func(ctx context.Context, p payload.Payload) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestStreamArgsMapArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestStreamArgsMap(ctx, inputArgs.Value)
		return flux.Map(response, transform.MapEncode(func(writer msgpack.Writer, key string) {
			writer.WriteString(key)
		}, func(writer msgpack.Writer, val string) {
			writer.WriteString(val)
		}))
	}
}

func myStreamerRequestChannelVoidWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		responseStream := svc.RequestChannelVoid(ctx, flux.Map(in, transform.Int64.Decode))
		response := transform.MonoToFlux(responseStream)
		return flux.Map(response, transform.Void.Encode)
	}
}

func myStreamerRequestChannelSingleWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		responseStream := svc.RequestChannelSingle(ctx, flux.Map(in, transform.Int64.Decode))
		response := transform.MonoToFlux(responseStream)
		return flux.Map(response, transform.Int64.Encode)
	}
}

func myStreamerRequestChannelI64Wrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		response := svc.RequestChannelI64(ctx, flux.Map(in, transform.Int64.Decode))
		return flux.Map(response, transform.Int64.Encode)
	}
}

func myStreamerRequestChannelF64Wrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		response := svc.RequestChannelF64(ctx, flux.Map(in, transform.Float64.Decode))
		return flux.Map(response, transform.Float64.Encode)
	}
}

func myStreamerRequestChannelTypeWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		response := svc.RequestChannelType(ctx, flux.Map(in, transform.MsgPackDecode[MyType]))
		return flux.Map(response, transform.MsgPackEncode[MyType])
	}
}

func myStreamerRequestChannelEnumWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		response := svc.RequestChannelEnum(ctx, flux.Map(in, transform.Int32Decode[MyEnum]))
		return flux.Map(response, transform.Int32Encode[MyEnum])
	}
}

func myStreamerRequestChannelAliasWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		response := svc.RequestChannelAlias(ctx, flux.Map(in, transform.ToStringDecode(func(val string) (uuid.UUID, error) {
			return uuid.Parse(val)
		})))
		return flux.Map(response, transform.ToStringEncode(
			func(v uuid.UUID) string { return v.String() }))
	}
}

func myStreamerRequestChannelStringWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		response := svc.RequestChannelString(ctx, flux.Map(in, transform.String.Decode))
		return flux.Map(response, transform.String.Encode)
	}
}

func myStreamerRequestChannelBoolWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		response := svc.RequestChannelBool(ctx, flux.Map(in, transform.Bool.Decode))
		return flux.Map(response, transform.Bool.Encode)
	}
}

func myStreamerRequestChannelDatetimeWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		response := svc.RequestChannelDatetime(ctx, flux.Map(in, transform.Time.Decode))
		return flux.Map(response, transform.Time.Encode)
	}
}

func myStreamerRequestChannelListWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		response := svc.RequestChannelList(ctx, flux.Map(in, transform.SliceDecode(func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		})))
		return flux.Map(response, transform.SliceEncode(func(writer msgpack.Writer, val string) {
			writer.WriteString(val)
		}))
	}
}

func myStreamerRequestChannelMapWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		response := svc.RequestChannelMap(ctx, flux.Map(in, transform.MapDecode(
			func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})))
		return flux.Map(response, transform.MapEncode(func(writer msgpack.Writer, key string) {
			writer.WriteString(key)
		}, func(writer msgpack.Writer, val string) {
			writer.WriteString(val)
		}))
	}
}

func myStreamerRequestChannelArgsSingleWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestChannelArgsSingleArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		responseStream := svc.RequestChannelArgsSingle(ctx, inputArgs.Value, flux.Map(in, transform.Int64.Decode))
		response := transform.MonoToFlux(responseStream)
		return flux.Map(response, transform.Int64.Encode)
	}
}

func myStreamerRequestChannelArgsI64Wrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestChannelArgsI64Args()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestChannelArgsI64(ctx, inputArgs.Value, flux.Map(in, transform.Int64.Decode))
		return flux.Map(response, transform.Int64.Encode)
	}
}

func myStreamerRequestChannelArgsF64Wrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestChannelArgsF64Args()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestChannelArgsF64(ctx, inputArgs.Value, flux.Map(in, transform.Float64.Decode))
		return flux.Map(response, transform.Float64.Encode)
	}
}

func myStreamerRequestChannelArgsTypeWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestChannelArgsTypeArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestChannelArgsType(ctx, &inputArgs.Value, flux.Map(in, transform.MsgPackDecode[MyType]))
		return flux.Map(response, transform.MsgPackEncode[MyType])
	}
}

func myStreamerRequestChannelArgsEnumWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestChannelArgsEnumArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestChannelArgsEnum(ctx, inputArgs.Value, flux.Map(in, transform.Int32Decode[MyEnum]))
		return flux.Map(response, transform.Int32Encode[MyEnum])
	}
}

func myStreamerRequestChannelArgsAliasWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestChannelArgsAliasArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestChannelArgsAlias(ctx, inputArgs.Value, flux.Map(in, transform.ToStringDecode(func(val string) (uuid.UUID, error) {
			return uuid.Parse(val)
		})))
		return flux.Map(response, transform.ToStringEncode(
			func(v uuid.UUID) string { return v.String() }))
	}
}

func myStreamerRequestChannelArgsStringWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestChannelArgsStringArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestChannelArgsString(ctx, inputArgs.Value, flux.Map(in, transform.String.Decode))
		return flux.Map(response, transform.String.Encode)
	}
}

func myStreamerRequestChannelArgsBoolWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestChannelArgsBoolArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestChannelArgsBool(ctx, inputArgs.Value, flux.Map(in, transform.Bool.Decode))
		return flux.Map(response, transform.Bool.Encode)
	}
}

func myStreamerRequestChannelArgsDatetimeWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestChannelArgsDatetimeArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestChannelArgsDatetime(ctx, inputArgs.Value, flux.Map(in, transform.Time.Decode))
		return flux.Map(response, transform.Time.Encode)
	}
}

func myStreamerRequestChannelArgsListWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestChannelArgsListArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestChannelArgsList(ctx, inputArgs.Value, flux.Map(in, transform.SliceDecode(func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		})))
		return flux.Map(response, transform.SliceEncode(func(writer msgpack.Writer, val string) {
			writer.WriteString(val)
		}))
	}
}

func myStreamerRequestChannelArgsMapWrapper(svc MyStreamer) invoke.RequestChannelHandler {
	return func(ctx context.Context, p payload.Payload, in flux.Flux[payload.Payload]) flux.Flux[payload.Payload] {
		inputArgs := DefaultMyStreamerRequestChannelArgsMapArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return flux.Error[payload.Payload](err)
		}
		response := svc.RequestChannelArgsMap(ctx, inputArgs.Value, flux.Map(in, transform.MapDecode(
			func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			}, func(decoder msgpack.Reader) (string, error) {
				return decoder.ReadString()
			})))
		return flux.Map(response, transform.MapEncode(func(writer msgpack.Writer, key string) {
			writer.WriteString(key)
		}, func(writer msgpack.Writer, val string) {
			writer.WriteString(val)
		}))
	}
}

func myServiceEmptyVoidWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		response := svc.EmptyVoid(ctx)
		return mono.Map(response, transform.Void.Encode)
	}
}

func myServiceUnaryTypeWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		var request MyType
		if err := transform.CodecDecode(p, &request); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryType(ctx, &request)
		return mono.Map(response, transform.MsgPackEncode[MyType])
	}
}

func myServiceUnaryEnumWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		enumVal, err := transform.Int32.Decode(p)
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		request := MyEnum(enumVal)
		response := svc.UnaryEnum(ctx, request)
		return mono.Map(response, transform.Int32Encode[MyEnum])
	}
}

func myServiceUnaryUUIDWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		aliasVal, err := transform.String.Decode(p)
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		request, err := uuid.Parse(aliasVal)
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryUUID(ctx, request)
		return mono.Map(response, transform.ToStringEncode(
			func(v uuid.UUID) string { return v.String() }))
	}
}

func myServiceUnaryAliasWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		aliasVal, err := transform.String.Decode(p)
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		request := MyAlias(aliasVal)
		response := svc.UnaryAlias(ctx, request)
		return mono.Map(response, transform.StringEncode[MyAlias])
	}
}

func myServiceUnaryStringWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		d := msgpack.NewDecoder(p.Data())
		decoder := &d
		request, err := decoder.ReadString()
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryString(ctx, request)
		return mono.Map(response, transform.String.Encode)
	}
}

func myServiceUnaryI64Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		d := msgpack.NewDecoder(p.Data())
		decoder := &d
		request, err := decoder.ReadInt64()
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryI64(ctx, request)
		return mono.Map(response, transform.Int64.Encode)
	}
}

func myServiceUnaryI32Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		d := msgpack.NewDecoder(p.Data())
		decoder := &d
		request, err := decoder.ReadInt32()
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryI32(ctx, request)
		return mono.Map(response, transform.Int32.Encode)
	}
}

func myServiceUnaryI16Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		d := msgpack.NewDecoder(p.Data())
		decoder := &d
		request, err := decoder.ReadInt16()
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryI16(ctx, request)
		return mono.Map(response, transform.Int16.Encode)
	}
}

func myServiceUnaryI8Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		d := msgpack.NewDecoder(p.Data())
		decoder := &d
		request, err := decoder.ReadInt8()
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryI8(ctx, request)
		return mono.Map(response, transform.Int8.Encode)
	}
}

func myServiceUnaryU64Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		d := msgpack.NewDecoder(p.Data())
		decoder := &d
		request, err := decoder.ReadUint64()
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryU64(ctx, request)
		return mono.Map(response, transform.Uint64.Encode)
	}
}

func myServiceUnaryU32Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		d := msgpack.NewDecoder(p.Data())
		decoder := &d
		request, err := decoder.ReadUint32()
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryU32(ctx, request)
		return mono.Map(response, transform.Uint32.Encode)
	}
}

func myServiceUnaryU16Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		d := msgpack.NewDecoder(p.Data())
		decoder := &d
		request, err := decoder.ReadUint16()
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryU16(ctx, request)
		return mono.Map(response, transform.Uint16.Encode)
	}
}

func myServiceUnaryU8Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		d := msgpack.NewDecoder(p.Data())
		decoder := &d
		request, err := decoder.ReadUint8()
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryU8(ctx, request)
		return mono.Map(response, transform.Uint8.Encode)
	}
}

func myServiceUnaryF64Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		d := msgpack.NewDecoder(p.Data())
		decoder := &d
		request, err := decoder.ReadFloat64()
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryF64(ctx, request)
		return mono.Map(response, transform.Float64.Encode)
	}
}

func myServiceUnaryF32Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		d := msgpack.NewDecoder(p.Data())
		decoder := &d
		request, err := decoder.ReadFloat32()
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryF32(ctx, request)
		return mono.Map(response, transform.Float32.Encode)
	}
}

func myServiceUnaryBytesWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		d := msgpack.NewDecoder(p.Data())
		decoder := &d
		request, err := decoder.ReadByteArray()
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryBytes(ctx, request)
		return mono.Map(response, transform.Bytes.Encode)
	}
}

func myServiceUnaryDatetimeWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		d := msgpack.NewDecoder(p.Data())
		decoder := &d
		request, err := decoder.ReadTime()
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryDatetime(ctx, request)
		return mono.Map(response, transform.Time.Encode)
	}
}

func myServiceUnaryListWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		d := msgpack.NewDecoder(p.Data())
		decoder := &d
		request, err := msgpack.ReadSlice(decoder, func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		})
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryList(ctx, request)
		return mono.Map(response, transform.SliceEncode(func(writer msgpack.Writer, val string) {
			writer.WriteString(val)
		}))
	}
}

func myServiceUnaryMapWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		d := msgpack.NewDecoder(p.Data())
		decoder := &d
		request, err := msgpack.ReadMap(decoder, func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}, func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		})
		if err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.UnaryMap(ctx, request)
		return mono.Map(response, transform.MapEncode(func(writer msgpack.Writer, key string) {
			writer.WriteString(key)
		}, func(writer msgpack.Writer, val string) {
			writer.WriteString(val)
		}))
	}
}

func myServiceFuncTypeWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncTypeArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncType(ctx, &inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.MsgPackEncode[MyType])
	}
}

func myServiceFuncEnumWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncEnumArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncEnum(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.Int32Encode[MyEnum])
	}
}

func myServiceFuncUUIDWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncUUIDArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncUUID(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.ToStringEncode(
			func(v uuid.UUID) string { return v.String() }))
	}
}

func myServiceFuncAliasWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncAliasArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncAlias(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.StringEncode[MyAlias])
	}
}

func myServiceFuncStringWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncStringArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncString(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.String.Encode)
	}
}

func myServiceFuncI64Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncI64Args()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncI64(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.Int64.Encode)
	}
}

func myServiceFuncI32Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncI32Args()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncI32(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.Int32.Encode)
	}
}

func myServiceFuncI16Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncI16Args()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncI16(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.Int16.Encode)
	}
}

func myServiceFuncI8Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncI8Args()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncI8(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.Int8.Encode)
	}
}

func myServiceFuncU64Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncU64Args()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncU64(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.Uint64.Encode)
	}
}

func myServiceFuncU32Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncU32Args()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncU32(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.Uint32.Encode)
	}
}

func myServiceFuncU16Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncU16Args()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncU16(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.Uint16.Encode)
	}
}

func myServiceFuncU8Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncU8Args()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncU8(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.Uint8.Encode)
	}
}

func myServiceFuncF64Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncF64Args()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncF64(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.Float64.Encode)
	}
}

func myServiceFuncF32Wrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncF32Args()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncF32(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.Float32.Encode)
	}
}

func myServiceFuncBytesWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncBytesArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncBytes(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.Bytes.Encode)
	}
}

func myServiceFuncDatetimeWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncDatetimeArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncDatetime(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.Time.Encode)
	}
}

func myServiceFuncListWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncListArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncList(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.SliceEncode(func(writer msgpack.Writer, val string) {
			writer.WriteString(val)
		}))
	}
}

func myServiceFuncMapWrapper(svc MyService) invoke.RequestResponseHandler {
	return func(ctx context.Context, p payload.Payload) mono.Mono[payload.Payload] {
		inputArgs := DefaultMyServiceFuncMapArgs()
		if err := transform.CodecDecode(p, &inputArgs); err != nil {
			return mono.Error[payload.Payload](err)
		}
		response := svc.FuncMap(ctx, inputArgs.Value, inputArgs.Optional)
		return mono.Map(response, transform.MapEncode(func(writer msgpack.Writer, key string) {
			writer.WriteString(key)
		}, func(writer msgpack.Writer, val string) {
			writer.WriteString(val)
		}))
	}
}

type Dependencies struct {
	Repository Repository
}

type Client struct {
	caller                                     invoke.Caller
	_opRepositoryRequestStreamI64              uint32
	_opRepositoryRequestStreamF64              uint32
	_opRepositoryRequestStreamType             uint32
	_opRepositoryRequestStreamEnum             uint32
	_opRepositoryRequestStreamUUID             uint32
	_opRepositoryRequestStreamAlias            uint32
	_opRepositoryRequestStreamString           uint32
	_opRepositoryRequestStreamBool             uint32
	_opRepositoryRequestStreamDatetime         uint32
	_opRepositoryRequestStreamList             uint32
	_opRepositoryRequestStreamMap              uint32
	_opRepositoryRequestStreamArgsI64          uint32
	_opRepositoryRequestStreamArgsF64          uint32
	_opRepositoryRequestStreamArgsType         uint32
	_opRepositoryRequestStreamArgsEnum         uint32
	_opRepositoryRequestStreamArgsUUID         uint32
	_opRepositoryRequestStreamArgsAlias        uint32
	_opRepositoryRequestStreamArgsString       uint32
	_opRepositoryRequestStreamArgsBool         uint32
	_opRepositoryRequestStreamArgsDatetime     uint32
	_opRepositoryRequestStreamArgsList         uint32
	_opRepositoryRequestStreamArgsMap          uint32
	_opRepositoryRequestChannelI64             uint32
	_opRepositoryRequestChannelF64             uint32
	_opRepositoryRequestChannelType            uint32
	_opRepositoryRequestChannelEnum            uint32
	_opRepositoryRequestChannelAlias           uint32
	_opRepositoryRequestChannelString          uint32
	_opRepositoryRequestChannelBool            uint32
	_opRepositoryRequestChannelDatetime        uint32
	_opRepositoryRequestChannelList            uint32
	_opRepositoryRequestChannelMap             uint32
	_opRepositoryRequestChannelArgsI64         uint32
	_opRepositoryRequestChannelArgsF64         uint32
	_opRepositoryRequestChannelArgsType        uint32
	_opRepositoryRequestChannelArgsEnum        uint32
	_opRepositoryRequestChannelArgsAlias       uint32
	_opRepositoryRequestChannelArgsString      uint32
	_opRepositoryRequestChannelArgsBool        uint32
	_opRepositoryRequestChannelArgsDatetime    uint32
	_opRepositoryRequestChannelArgsList        uint32
	_opRepositoryRequestChannelArgsMap         uint32
	_opRepositoryRequestChannelVoid            uint32
	_opRepositoryRequestChannelNonStreamOutput uint32
}

func New(caller invoke.Caller) *Client {
	return &Client{
		caller:                                     caller,
		_opRepositoryRequestStreamI64:              invoke.ImportRequestStream("iota.testing.Repository", "requestStreamI64"),
		_opRepositoryRequestStreamF64:              invoke.ImportRequestStream("iota.testing.Repository", "requestStreamF64"),
		_opRepositoryRequestStreamType:             invoke.ImportRequestStream("iota.testing.Repository", "requestStreamType"),
		_opRepositoryRequestStreamEnum:             invoke.ImportRequestStream("iota.testing.Repository", "requestStreamEnum"),
		_opRepositoryRequestStreamUUID:             invoke.ImportRequestStream("iota.testing.Repository", "requestStreamUUID"),
		_opRepositoryRequestStreamAlias:            invoke.ImportRequestStream("iota.testing.Repository", "requestStreamAlias"),
		_opRepositoryRequestStreamString:           invoke.ImportRequestStream("iota.testing.Repository", "requestStreamString"),
		_opRepositoryRequestStreamBool:             invoke.ImportRequestStream("iota.testing.Repository", "requestStreamBool"),
		_opRepositoryRequestStreamDatetime:         invoke.ImportRequestStream("iota.testing.Repository", "requestStreamDatetime"),
		_opRepositoryRequestStreamList:             invoke.ImportRequestStream("iota.testing.Repository", "requestStreamList"),
		_opRepositoryRequestStreamMap:              invoke.ImportRequestStream("iota.testing.Repository", "requestStreamMap"),
		_opRepositoryRequestStreamArgsI64:          invoke.ImportRequestStream("iota.testing.Repository", "requestStreamArgsI64"),
		_opRepositoryRequestStreamArgsF64:          invoke.ImportRequestStream("iota.testing.Repository", "requestStreamArgsF64"),
		_opRepositoryRequestStreamArgsType:         invoke.ImportRequestStream("iota.testing.Repository", "requestStreamArgsType"),
		_opRepositoryRequestStreamArgsEnum:         invoke.ImportRequestStream("iota.testing.Repository", "requestStreamArgsEnum"),
		_opRepositoryRequestStreamArgsUUID:         invoke.ImportRequestStream("iota.testing.Repository", "requestStreamArgsUUID"),
		_opRepositoryRequestStreamArgsAlias:        invoke.ImportRequestStream("iota.testing.Repository", "requestStreamArgsAlias"),
		_opRepositoryRequestStreamArgsString:       invoke.ImportRequestStream("iota.testing.Repository", "requestStreamArgsString"),
		_opRepositoryRequestStreamArgsBool:         invoke.ImportRequestStream("iota.testing.Repository", "requestStreamArgsBool"),
		_opRepositoryRequestStreamArgsDatetime:     invoke.ImportRequestStream("iota.testing.Repository", "requestStreamArgsDatetime"),
		_opRepositoryRequestStreamArgsList:         invoke.ImportRequestStream("iota.testing.Repository", "requestStreamArgsList"),
		_opRepositoryRequestStreamArgsMap:          invoke.ImportRequestStream("iota.testing.Repository", "requestStreamArgsMap"),
		_opRepositoryRequestChannelI64:             invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelI64"),
		_opRepositoryRequestChannelF64:             invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelF64"),
		_opRepositoryRequestChannelType:            invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelType"),
		_opRepositoryRequestChannelEnum:            invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelEnum"),
		_opRepositoryRequestChannelAlias:           invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelAlias"),
		_opRepositoryRequestChannelString:          invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelString"),
		_opRepositoryRequestChannelBool:            invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelBool"),
		_opRepositoryRequestChannelDatetime:        invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelDatetime"),
		_opRepositoryRequestChannelList:            invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelList"),
		_opRepositoryRequestChannelMap:             invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelMap"),
		_opRepositoryRequestChannelArgsI64:         invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelArgsI64"),
		_opRepositoryRequestChannelArgsF64:         invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelArgsF64"),
		_opRepositoryRequestChannelArgsType:        invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelArgsType"),
		_opRepositoryRequestChannelArgsEnum:        invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelArgsEnum"),
		_opRepositoryRequestChannelArgsAlias:       invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelArgsAlias"),
		_opRepositoryRequestChannelArgsString:      invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelArgsString"),
		_opRepositoryRequestChannelArgsBool:        invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelArgsBool"),
		_opRepositoryRequestChannelArgsDatetime:    invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelArgsDatetime"),
		_opRepositoryRequestChannelArgsList:        invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelArgsList"),
		_opRepositoryRequestChannelArgsMap:         invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelArgsMap"),
		_opRepositoryRequestChannelVoid:            invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelVoid"),
		_opRepositoryRequestChannelNonStreamOutput: invoke.ImportRequestChannel("iota.testing.Repository", "requestChannelNonStreamOutput"),
	}
}
func (c *Client) Dependencies() Dependencies {
	return Dependencies{
		Repository: c.Repository(),
	}
}

func GetDependencies(caller invoke.Caller) Dependencies {
	c := New(caller)
	return c.Dependencies()
}

type RepositoryClient struct {
	c          *Client
	instanceID uint64
}

func (c *Client) Repository() Repository {
	return &RepositoryClient{
		c: c,
	}
}

func (r *RepositoryClient) RequestStreamI64(ctx context.Context) flux.Flux[int64] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamI64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Int64.Decode)
}

func (r *RepositoryClient) RequestStreamF64(ctx context.Context) flux.Flux[float64] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamF64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Float64.Decode)
}

func (r *RepositoryClient) RequestStreamType(ctx context.Context) flux.Flux[MyType] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamType)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[MyType])
}

func (r *RepositoryClient) RequestStreamEnum(ctx context.Context) flux.Flux[MyEnum] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamEnum)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Int32Decode[MyEnum])
}

func (r *RepositoryClient) RequestStreamUUID(ctx context.Context) flux.Flux[uuid.UUID] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamUUID)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.ToStringDecode(func(val string) (uuid.UUID, error) {
		return uuid.Parse(val)
	}))
}

func (r *RepositoryClient) RequestStreamAlias(ctx context.Context) flux.Flux[MyAlias] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamAlias)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.StringDecode[MyAlias])
}

func (r *RepositoryClient) RequestStreamString(ctx context.Context) flux.Flux[string] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamString)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.String.Decode)
}

func (r *RepositoryClient) RequestStreamBool(ctx context.Context) flux.Flux[bool] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamBool)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Bool.Decode)
}

func (r *RepositoryClient) RequestStreamDatetime(ctx context.Context) flux.Flux[time.Time] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamDatetime)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Time.Decode)
}

func (r *RepositoryClient) RequestStreamList(ctx context.Context) flux.Flux[[]string] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamList)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.SliceDecode(func(decoder msgpack.Reader) (string, error) {
		return decoder.ReadString()
	}))
}

func (r *RepositoryClient) RequestStreamMap(ctx context.Context) flux.Flux[map[string]string] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamMap)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MapDecode(
		func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}, func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}))
}

func (r *RepositoryClient) RequestStreamArgsI64(ctx context.Context, value int64) flux.Flux[int64] {
	request := RepositoryRequestStreamArgsI64Args{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[int64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamArgsI64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Int64.Decode)
}

func (r *RepositoryClient) RequestStreamArgsF64(ctx context.Context, value float64) flux.Flux[float64] {
	request := RepositoryRequestStreamArgsF64Args{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[float64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamArgsF64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Float64.Decode)
}

func (r *RepositoryClient) RequestStreamArgsType(ctx context.Context, value *MyType) flux.Flux[MyType] {
	request := RepositoryRequestStreamArgsTypeArgs{
		Value: *value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[MyType](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamArgsType)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MsgPackDecode[MyType])
}

func (r *RepositoryClient) RequestStreamArgsEnum(ctx context.Context, value MyEnum) flux.Flux[MyEnum] {
	request := RepositoryRequestStreamArgsEnumArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[MyEnum](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamArgsEnum)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Int32Decode[MyEnum])
}

func (r *RepositoryClient) RequestStreamArgsUUID(ctx context.Context, value uuid.UUID) flux.Flux[uuid.UUID] {
	request := RepositoryRequestStreamArgsUUIDArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[uuid.UUID](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamArgsUUID)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.ToStringDecode(func(val string) (uuid.UUID, error) {
		return uuid.Parse(val)
	}))
}

func (r *RepositoryClient) RequestStreamArgsAlias(ctx context.Context, value MyAlias) flux.Flux[MyAlias] {
	request := RepositoryRequestStreamArgsAliasArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[MyAlias](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamArgsAlias)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.StringDecode[MyAlias])
}

func (r *RepositoryClient) RequestStreamArgsString(ctx context.Context, value string) flux.Flux[string] {
	request := RepositoryRequestStreamArgsStringArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamArgsString)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.String.Decode)
}

func (r *RepositoryClient) RequestStreamArgsBool(ctx context.Context, value bool) flux.Flux[bool] {
	request := RepositoryRequestStreamArgsBoolArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[bool](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamArgsBool)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Bool.Decode)
}

func (r *RepositoryClient) RequestStreamArgsDatetime(ctx context.Context, value time.Time) flux.Flux[time.Time] {
	request := RepositoryRequestStreamArgsDatetimeArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[time.Time](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamArgsDatetime)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.Time.Decode)
}

func (r *RepositoryClient) RequestStreamArgsList(ctx context.Context, value []string) flux.Flux[[]string] {
	request := RepositoryRequestStreamArgsListArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[[]string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamArgsList)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.SliceDecode(func(decoder msgpack.Reader) (string, error) {
		return decoder.ReadString()
	}))
}

func (r *RepositoryClient) RequestStreamArgsMap(ctx context.Context, value map[string]string) flux.Flux[map[string]string] {
	request := RepositoryRequestStreamArgsMapArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[map[string]string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestStreamArgsMap)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestStream(ctx, pl)
	return flux.Map(future, transform.MapDecode(
		func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}, func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}))
}

func (r *RepositoryClient) RequestChannelI64(ctx context.Context, in flux.Flux[int64]) flux.Flux[int64] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelI64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Int64.Encode))
	return flux.Map(future, transform.Int64.Decode)
}

func (r *RepositoryClient) RequestChannelF64(ctx context.Context, in flux.Flux[float64]) flux.Flux[float64] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelF64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Float64.Encode))
	return flux.Map(future, transform.Float64.Decode)
}

func (r *RepositoryClient) RequestChannelType(ctx context.Context, in flux.Flux[MyType]) flux.Flux[MyType] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelType)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.MsgPackEncode[MyType]))
	return flux.Map(future, transform.MsgPackDecode[MyType])
}

func (r *RepositoryClient) RequestChannelEnum(ctx context.Context, in flux.Flux[MyEnum]) flux.Flux[MyEnum] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelEnum)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Int32Encode[MyEnum]))
	return flux.Map(future, transform.Int32Decode[MyEnum])
}

func (r *RepositoryClient) RequestChannelAlias(ctx context.Context, in flux.Flux[uuid.UUID]) flux.Flux[uuid.UUID] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelAlias)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.ToStringEncode(func(val uuid.UUID) string {
		return val.String()
	})))
	return flux.Map(future, transform.ToStringDecode(func(val string) (uuid.UUID, error) {
		return uuid.Parse(val)
	}))
}

func (r *RepositoryClient) RequestChannelString(ctx context.Context, in flux.Flux[string]) flux.Flux[string] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelString)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.String.Encode))
	return flux.Map(future, transform.String.Decode)
}

func (r *RepositoryClient) RequestChannelBool(ctx context.Context, in flux.Flux[bool]) flux.Flux[bool] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelBool)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Bool.Encode))
	return flux.Map(future, transform.Bool.Decode)
}

func (r *RepositoryClient) RequestChannelDatetime(ctx context.Context, in flux.Flux[time.Time]) flux.Flux[time.Time] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelDatetime)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Time.Encode))
	return flux.Map(future, transform.Time.Decode)
}

func (r *RepositoryClient) RequestChannelList(ctx context.Context, in flux.Flux[[]string]) flux.Flux[[]string] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelList)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.SliceEncode(func(writer msgpack.Writer, val string) {
		writer.WriteString(val)
	})))
	return flux.Map(future, transform.SliceDecode(func(decoder msgpack.Reader) (string, error) {
		return decoder.ReadString()
	}))
}

func (r *RepositoryClient) RequestChannelMap(ctx context.Context, in flux.Flux[map[string]string]) flux.Flux[map[string]string] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelMap)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.MapEncode(func(writer msgpack.Writer, key string) {
		writer.WriteString(key)
	}, func(writer msgpack.Writer, val string) {
		writer.WriteString(val)
	})))
	return flux.Map(future, transform.MapDecode(
		func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}, func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}))
}

func (r *RepositoryClient) RequestChannelArgsI64(ctx context.Context, value int64, in flux.Flux[int64]) flux.Flux[int64] {
	request := RepositoryRequestChannelArgsI64Args{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[int64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelArgsI64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Int64.Encode))
	return flux.Map(future, transform.Int64.Decode)
}

func (r *RepositoryClient) RequestChannelArgsF64(ctx context.Context, value float64, in flux.Flux[float64]) flux.Flux[float64] {
	request := RepositoryRequestChannelArgsF64Args{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[float64](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelArgsF64)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Float64.Encode))
	return flux.Map(future, transform.Float64.Decode)
}

func (r *RepositoryClient) RequestChannelArgsType(ctx context.Context, value *MyType, in flux.Flux[MyType]) flux.Flux[MyType] {
	request := RepositoryRequestChannelArgsTypeArgs{
		Value: *value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[MyType](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelArgsType)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.MsgPackEncode[MyType]))
	return flux.Map(future, transform.MsgPackDecode[MyType])
}

func (r *RepositoryClient) RequestChannelArgsEnum(ctx context.Context, value MyEnum, in flux.Flux[MyEnum]) flux.Flux[MyEnum] {
	request := RepositoryRequestChannelArgsEnumArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[MyEnum](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelArgsEnum)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Int32Encode[MyEnum]))
	return flux.Map(future, transform.Int32Decode[MyEnum])
}

func (r *RepositoryClient) RequestChannelArgsAlias(ctx context.Context, value uuid.UUID, in flux.Flux[uuid.UUID]) flux.Flux[uuid.UUID] {
	request := RepositoryRequestChannelArgsAliasArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[uuid.UUID](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelArgsAlias)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.ToStringEncode(func(val uuid.UUID) string {
		return val.String()
	})))
	return flux.Map(future, transform.ToStringDecode(func(val string) (uuid.UUID, error) {
		return uuid.Parse(val)
	}))
}

func (r *RepositoryClient) RequestChannelArgsString(ctx context.Context, value string, in flux.Flux[string]) flux.Flux[string] {
	request := RepositoryRequestChannelArgsStringArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelArgsString)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.String.Encode))
	return flux.Map(future, transform.String.Decode)
}

func (r *RepositoryClient) RequestChannelArgsBool(ctx context.Context, value bool, in flux.Flux[bool]) flux.Flux[bool] {
	request := RepositoryRequestChannelArgsBoolArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[bool](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelArgsBool)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Bool.Encode))
	return flux.Map(future, transform.Bool.Decode)
}

func (r *RepositoryClient) RequestChannelArgsDatetime(ctx context.Context, value time.Time, in flux.Flux[time.Time]) flux.Flux[time.Time] {
	request := RepositoryRequestChannelArgsDatetimeArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[time.Time](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelArgsDatetime)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Time.Encode))
	return flux.Map(future, transform.Time.Decode)
}

func (r *RepositoryClient) RequestChannelArgsList(ctx context.Context, value []string, in flux.Flux[[]string]) flux.Flux[[]string] {
	request := RepositoryRequestChannelArgsListArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[[]string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelArgsList)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.SliceEncode(func(writer msgpack.Writer, val string) {
		writer.WriteString(val)
	})))
	return flux.Map(future, transform.SliceDecode(func(decoder msgpack.Reader) (string, error) {
		return decoder.ReadString()
	}))
}

func (r *RepositoryClient) RequestChannelArgsMap(ctx context.Context, value map[string]string, in flux.Flux[map[string]string]) flux.Flux[map[string]string] {
	request := RepositoryRequestChannelArgsMapArgs{
		Value: value,
	}
	payloadData, err := msgpack.ToBytes(&request)
	if err != nil {
		return flux.Error[map[string]string](err)
	}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelArgsMap)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.MapEncode(func(writer msgpack.Writer, key string) {
		writer.WriteString(key)
	}, func(writer msgpack.Writer, val string) {
		writer.WriteString(val)
	})))
	return flux.Map(future, transform.MapDecode(
		func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}, func(decoder msgpack.Reader) (string, error) {
			return decoder.ReadString()
		}))
}

func (r *RepositoryClient) RequestChannelVoid(ctx context.Context, in flux.Flux[int64]) mono.Void {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelVoid)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	future := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Int64.Encode))
	return transform.FluxToVoid(future)
}

func (r *RepositoryClient) RequestChannelNonStreamOutput(ctx context.Context, in flux.Flux[int64]) mono.Mono[string] {
	payloadData := []byte{}
	var metadata [16]byte
	stream, ok := proxy.FromContext(ctx)
	binary.BigEndian.PutUint32(metadata[0:4], r.c._opRepositoryRequestChannelNonStreamOutput)
	if ok {
		binary.BigEndian.PutUint32(metadata[4:8], stream.StreamID())
	}
	pl := payload.New(payloadData, metadata[:])
	futureStream := r.c.caller.RequestChannel(ctx, pl, flux.Map(in, transform.Int64.Encode))
	future := transform.FluxToMono(futureStream)
	return mono.Map(future, transform.String.Decode)
}
